{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/imgs/2149115-a75ab976a221b88c.png","path":"imgs/2149115-a75ab976a221b88c.png","modified":0,"renderable":0},{"_id":"source/imgs/4c1c8e5bfd6663f788acb9a9665f3ffc.jpg","path":"imgs/4c1c8e5bfd6663f788acb9a9665f3ffc.jpg","modified":0,"renderable":0},{"_id":"source/imgs/EventBus-Publish-Subscribe.png","path":"imgs/EventBus-Publish-Subscribe.png","modified":0,"renderable":0},{"_id":"source/imgs/2149115-f2becc1a2a11fcfc.jpg","path":"imgs/2149115-f2becc1a2a11fcfc.jpg","modified":0,"renderable":0},{"_id":"source/imgs/notification_01.png","path":"imgs/notification_01.png","modified":0,"renderable":0},{"_id":"source/imgs/notification_02.png","path":"imgs/notification_02.png","modified":0,"renderable":0},{"_id":"source/imgs/notification_03.png","path":"imgs/notification_03.png","modified":0,"renderable":0},{"_id":"source/imgs/notification_04.png","path":"imgs/notification_04.png","modified":0,"renderable":0},{"_id":"source/imgs/8c91ad2096d7aaea9dc52dc4c86a8d58.jpg","path":"imgs/8c91ad2096d7aaea9dc52dc4c86a8d58.jpg","modified":0,"renderable":0},{"_id":"source/imgs/EventBus-Top.jpg","path":"imgs/EventBus-Top.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/bitbug_favicon.ico","path":"images/bitbug_favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/conon.jpg","path":"images/conon.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fastclick/LICENSE","path":"VENS/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fastclick/README.md","path":"VENS/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fastclick/bower.json","path":"VENS/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/jquery_lazyload/CONTRIBUTING.md","path":"VENS/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/jquery_lazyload/README.md","path":"VENS/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/jquery_lazyload/bower.json","path":"VENS/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/jquery_lazyload/jquery.scrollstop.js","path":"VENS/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/jquery_lazyload/jquery.lazyload.js","path":"VENS/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/HELP-US-OUT.txt","path":"VENS/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/bower.json","path":"VENS/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/velocity/bower.json","path":"VENS/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/velocity/velocity.min.js","path":"VENS/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/velocity/velocity.ui.js","path":"VENS/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/velocity/velocity.ui.min.js","path":"VENS/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/jquery/index.js","path":"VENS/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/blank.gif","path":"VENS/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/fancybox_loading.gif","path":"VENS/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/fancybox_loading@2x.gif","path":"VENS/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/fancybox_sprite.png","path":"VENS/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/fancybox_sprite@2x.png","path":"VENS/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/jquery.fancybox.css","path":"VENS/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/jquery.fancybox.js","path":"VENS/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/fancybox_overlay.png","path":"VENS/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/jquery.fancybox.pack.js","path":"VENS/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fastclick/lib/fastclick.js","path":"VENS/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fastclick/lib/fastclick.min.js","path":"VENS/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/ua-parser-js/dist/ua-parser.min.js","path":"VENS/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/ua-parser-js/dist/ua-parser.pack.js","path":"VENS/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/css/font-awesome.min.css","path":"VENS/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/css/font-awesome.css.map","path":"VENS/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/fonts/fontawesome-webfont.woff2","path":"VENS/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/css/font-awesome.css","path":"VENS/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/fonts/FontAwesome.otf","path":"VENS/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/fonts/fontawesome-webfont.eot","path":"VENS/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/fonts/fontawesome-webfont.woff","path":"VENS/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/velocity/velocity.js","path":"VENS/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/helpers/fancybox_buttons.png","path":"VENS/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"VENS/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"VENS/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/helpers/jquery.fancybox-media.js","path":"VENS/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"VENS/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"VENS/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/fonts/fontawesome-webfont.ttf","path":"VENS/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/VENS/font-awesome/fonts/fontawesome-webfont.svg","path":"VENS/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"5aedc8f6034a6a65127d2f9938cdab8b396bbcdc","modified":1480555932000},{"_id":"source/_posts/Retrofit2-1学习-与Rxjava结合使用.md","hash":"70c2d578bb0f775573491d69312b70c483b3a0f4","modified":1479092281000},{"_id":"source/_posts/Android性能优化方法：内存泄露优化.md","hash":"0272184dae2340591de94c086f2fffab044727c3","modified":1478829412000},{"_id":"source/404.md","hash":"99b7e6e4bc6024c82b88c55e05eaff29905c371e","modified":1479261096000},{"_id":"source/_posts/Retrofit2-1学习：Call接口的使用.md","hash":"6dc354e6ede0ace407c8c1850962b119d2e43d96","modified":1479108958000},{"_id":"source/_posts/Retrofit2-1学习-与okhttp3-0结合使用.md","hash":"ff0624f14a837187a5418b9beb5d78d2df7991dc","modified":1479092304000},{"_id":"source/_posts/.DS_Store","hash":"84330595e1774609d2525cd3a2ac1287dcf6e288","modified":1479086072000},{"_id":"source/_posts/Retrofit2-1官方文档的翻译.md","hash":"f0f284cf7054700146e2adc32b64fee027229382","modified":1472806620000},{"_id":"source/_posts/Rxjava学习：Rxjava的进阶.md","hash":"643a1ec36303e40458ce1e1e35b1f08e5848b2e7","modified":1473062627000},{"_id":"source/_posts/从EventBus2-0-到-EventBus3-0.md","hash":"0507a2d78254a6c89f7c79d66dddde691c0b5a3d","modified":1480062239000},{"_id":"source/_posts/Rxjava学习：初识Rxjava.md","hash":"4f1e71c837af3b6859942b14b16390212e009e29","modified":1472806663000},{"_id":"source/_posts/消息栏通知Notification的那些事儿.md","hash":"23aace5d8113fa08d96b6d27dde7465a1f5b5103","modified":1480556080000},{"_id":"source/categories/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1472116472000},{"_id":"source/_posts/Rxjava学习：谈谈Rxjava的使用.md","hash":"ff768b7c80e894ec1900fc06e3631404d70e8ee7","modified":1472806674000},{"_id":"source/_posts/图片加载库Glide的入门使用.md","hash":"f28bbab60dda0b80fb1ab960e290588c6a888067","modified":1480061931000},{"_id":"source/imgs/2149115-a75ab976a221b88c.png","hash":"1a5255be24e7b26159c8633a09c4b31314a3f2a3","modified":1477876916000},{"_id":"source/about/index.md","hash":"05e0baa8909e42cf35028c09106a8a2291cf27a7","modified":1480556540000},{"_id":"source/imgs/4c1c8e5bfd6663f788acb9a9665f3ffc.jpg","hash":"267b7da18f54e50296af7cf94e9d36b2e00d3c14","modified":1473062441000},{"_id":"source/_posts/hello-world.md","hash":"82c62fd6a7bb23487c483d6d18b063476c56797b","modified":1472028863000},{"_id":"source/imgs/EventBus-Publish-Subscribe.png","hash":"78fd3a7b098edf5ae91a7b09fbedf7dc56ddda13","modified":1480062170000},{"_id":"source/imgs/2149115-f2becc1a2a11fcfc.jpg","hash":"e9c7b5d947e52e0c3535f6f0bd5ec113c9493a56","modified":1477876683000},{"_id":"source/imgs/notification_01.png","hash":"0cc3affcebbb42cf3bdb121d20329b72c3a0acc0","modified":1480555759000},{"_id":"source/imgs/notification_02.png","hash":"ff3084930996bf8bb5340561bae0e9cc36f4ef92","modified":1480555761000},{"_id":"source/tags/index.md","hash":"b86e35711f0e8cb7cd23546eb2c5af117a5aeabe","modified":1472116766000},{"_id":"source/imgs/notification_03.png","hash":"854ae9ca22b30cd2f0757d5025234ee6dd124591","modified":1480556021000},{"_id":"source/imgs/notification_04.png","hash":"18ada5a0a28a8d4867a8e4fcd7d7ca378243cd40","modified":1480555756000},{"_id":"source/imgs/8c91ad2096d7aaea9dc52dc4c86a8d58.jpg","hash":"d68d1b9c5ba6d9b98783e5cfbe4558df22d7466b","modified":1472117881000},{"_id":"source/tags/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1472116634000},{"_id":"source/categories/index.md","hash":"d9dda5c77d0c62f9db0be24bae09affaccae3596","modified":1472116730000},{"_id":"source/imgs/EventBus-Top.jpg","hash":"ddfe8d673801882b435c319331750ccb84719112","modified":1480062168000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1471830514000},{"_id":"themes/next/.gitignore","hash":"c8d6a73b9e17f0f8a3716e4ada6960d3180425a6","modified":1471830514000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1471830514000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1471830514000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1471830514000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1471830514000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1471830514000},{"_id":"themes/next/.DS_Store","hash":"e305f256e24bcffd5d7bdff8c5b895b03f4a5bed","modified":1479093650000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1471830514000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1471830514000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1471830514000},{"_id":"themes/next/_config.yml","hash":"78dda165c9843889d5737d68c737f8ff43bcc161","modified":1480062351000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1471830514000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1471830514000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1471830514000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1471830514000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1471830514000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1471830514000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1471830514000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1471830514000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1471830514000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1471830514000},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1471830514000},{"_id":"themes/next/languages/ko.yml","hash":"ce8b047c89daae77c03482fc76f16ffec6bdbf2d","modified":1471830514000},{"_id":"themes/next/scripts/.DS_Store","hash":"3c458f627384d2fe2d3df3249f240c64dfce6453","modified":1471932138000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1471830514000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1471830514000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1471830514000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1471830514000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1471830514000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1471830514000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1471830514000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1471830514000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1471830514000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1471830514000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1471830514000},{"_id":"themes/next/layout/.DS_Store","hash":"d39fb8eacd3f66ec7b43f2c4b6d361099044aaa3","modified":1471922519000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1471830514000},{"_id":"themes/next/source/.DS_Store","hash":"7ca56a4647eb0465d6d9b93d7b4069033e42a9cb","modified":1479093661000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1471830514000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1471830514000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1471830514000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471830514000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1471830514000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1471830514000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1471830514000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1471830514000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1471830514000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1471830514000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1471830514000},{"_id":"themes/next/layout/_macro/post.swig","hash":"3e23524cdc246f736601ed1f2957d245c214735e","modified":1471922634000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1471830514000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1471830514000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1471830514000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1471830514000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1471830514000},{"_id":"themes/next/layout/_scripts/lean-analytics.swig","hash":"63c82d93d3a9a55ad1b984d89a0814b87cb09d86","modified":1471922479000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"58fd826ca75b0cbc48b61a58da4b841e2fa34403","modified":1471830514000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1471830514000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1471830514000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1471830514000},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1471830514000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1471830514000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1471830514000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1471830514000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1471830514000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1471830514000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1471830514000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1471830514000},{"_id":"themes/next/source/images/bitbug_favicon.ico","hash":"0f777bd8a0d2ac890d22e4fc13a1b3223faf7564","modified":1471933044000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1471830514000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1471830514000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1471830514000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1471830514000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1471830514000},{"_id":"themes/next/source/images/conon.jpg","hash":"81ffbd1712afe8cdf138b570c0fc9934742c33c1","modified":1471933044000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1471830514000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1471830514000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471830514000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471830514000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471830514000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471830514000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471830514000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1471830514000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471830514000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471830514000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1471830514000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1471830514000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1471830514000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1471830514000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1471830514000},{"_id":"themes/next/source/VENS/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1471830514000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1471830514000},{"_id":"themes/next/source/VENS/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1471830514000},{"_id":"themes/next/source/VENS/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1471830514000},{"_id":"themes/next/source/VENS/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1471830514000},{"_id":"themes/next/source/VENS/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1471830514000},{"_id":"themes/next/source/VENS/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1471830514000},{"_id":"themes/next/source/VENS/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1471830514000},{"_id":"themes/next/source/VENS/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1471830514000},{"_id":"themes/next/source/VENS/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1471830514000},{"_id":"themes/next/source/VENS/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1471830514000},{"_id":"themes/next/source/VENS/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1471830514000},{"_id":"themes/next/source/VENS/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1471830514000},{"_id":"themes/next/source/VENS/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1471830514000},{"_id":"themes/next/source/VENS/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1471830514000},{"_id":"themes/next/source/VENS/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1471830514000},{"_id":"themes/next/source/VENS/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1471830514000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1471830514000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1471830514000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1471830514000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1471830514000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1471830514000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1471830514000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1471830514000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1471830514000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1471830514000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1471830514000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1471830514000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1471830514000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1471830514000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1471830514000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1471830514000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1471830514000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1471830514000},{"_id":"themes/next/source/VENS/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1471830514000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1471830514000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1471830514000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1471830514000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1471830514000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1471830514000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1471830514000},{"_id":"themes/next/source/VENS/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1471830514000},{"_id":"themes/next/source/VENS/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1471830514000},{"_id":"themes/next/source/VENS/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1471830514000},{"_id":"themes/next/source/VENS/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"1e3e1c6231408e18e8485a8e0e59e8880349b210","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1471830514000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1471830514000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1471830514000},{"_id":"themes/next/source/VENS/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1471830514000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1471830514000},{"_id":"themes/next/source/VENS/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1471830514000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1471830514000},{"_id":"themes/next/source/VENS/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1471830514000},{"_id":"public/404.html","hash":"db1309df06b5179c55f9db56c732e812064fe3c6","modified":1480556096625},{"_id":"public/tags/index.html","hash":"40f37bad59c265003658d24e40020cf1d74e3d29","modified":1480556096635},{"_id":"public/about/index.html","hash":"db430ab41ad32bd2b97055aa67023e6cda26c993","modified":1480556565288},{"_id":"public/categories/index.html","hash":"bcb6da757740f9d7002875bbd3a9b21081e6b9ed","modified":1480556096739},{"_id":"public/archives/index.html","hash":"7d4f7e6064914a659a3139d5493f222a8ff11050","modified":1480556096740},{"_id":"public/archives/page/2/index.html","hash":"7bdcb40278195861fb2eae0b592604cab80b61e5","modified":1480556096740},{"_id":"public/archives/2016/index.html","hash":"fca0645ff29f78f26f15f1b4c486d578772bf1f1","modified":1480556096740},{"_id":"public/archives/page/3/index.html","hash":"e544fc3448b95273d361ba813d34d1851532735b","modified":1480556096740},{"_id":"public/archives/2016/page/2/index.html","hash":"15b5816c629c4555a829729bde4009257926f0cf","modified":1480556096740},{"_id":"public/archives/2016/08/index.html","hash":"a1ef4709af44d252dbf29286fcc6dcacdd93efad","modified":1480556096740},{"_id":"public/archives/2016/page/3/index.html","hash":"dd630f2f4ec3c094a682002071ae5f9132609677","modified":1480556096740},{"_id":"public/archives/2016/09/index.html","hash":"096d1fa404a1744f12fe30caacd54b9591dd92cf","modified":1480556096740},{"_id":"public/archives/2016/10/index.html","hash":"04f9228ab3ded595d00b2c8ae7dfc7c8e3489c40","modified":1480556096740},{"_id":"public/archives/2016/11/index.html","hash":"454c3e9c85dddd1a7ba97baf4905a57f45cdf447","modified":1480556096740},{"_id":"public/categories/Retrofit2-1/index.html","hash":"1c9ca5fdd0eac165aa1a464d3c8ad7676ffc025a","modified":1480556096740},{"_id":"public/categories/android开发艺术谈说/index.html","hash":"2ea25e5376022419ee397ee17c32ed2c68c3d293","modified":1480556096740},{"_id":"public/categories/Rxjava学习/index.html","hash":"adadae2ea656588c4f42d0594ac04e22bcce28d4","modified":1480556096740},{"_id":"public/categories/EventBus/index.html","hash":"569e010207afd6586a6a58089a196f1404a884ac","modified":1480556096740},{"_id":"public/categories/Glide的使用/index.html","hash":"431a0bb8ba86db6c75fc6d6f4e5460bc67bf287b","modified":1480556096740},{"_id":"public/tags/Rxjava/index.html","hash":"745b4176f2a73863f193c4fbe5a59e0bf702c1db","modified":1480556096740},{"_id":"public/page/3/index.html","hash":"73d7037aef7672ae6b0e66ccafc0743732582a4d","modified":1480556096740},{"_id":"public/tags/EventBus2-0/index.html","hash":"4413550f17e705c91a2d9bef3fdb00411c7e301a","modified":1480556096741},{"_id":"public/tags/EventBus3-0/index.html","hash":"cb9c7241f17ca6d7404dcc54ef721f0c3aaa9347","modified":1480556096741},{"_id":"public/tags/RxAndroid/index.html","hash":"b881d396f6daed9e6c3b771fc0f32b828bacc701","modified":1480556096741},{"_id":"public/tags/world/index.html","hash":"b2e9e3590bcbaac277584bbb2b50ae457df446eb","modified":1480556096741},{"_id":"public/tags/hello/index.html","hash":"9142b36c7b2c52fd0ef2bf0e7f787f4d2d976b8d","modified":1480556096741},{"_id":"public/2016/11/25/图片加载库Glide的入门使用/index.html","hash":"51ee8a5555b52b7db0d4d9b290fa3cfecac85726","modified":1480556096741},{"_id":"public/2016/11/11/Retrofit2-1学习-与Rxjava结合使用/index.html","hash":"62d15c1fdfcc798aa4080a9bbde6fa8bc27495c2","modified":1480556096741},{"_id":"public/2016/10/31/Retrofit2-1学习-与okhttp3-0结合使用/index.html","hash":"efea8e1d9f7a1400a51291dcf046c7490562fb56","modified":1480556096741},{"_id":"public/2016/09/05/Rxjava学习：Rxjava的进阶/index.html","hash":"a104948a46f46c1bf705f974627485f6e8b62cd5","modified":1480556096741},{"_id":"public/2016/09/02/Retrofit2-1官方文档的翻译/index.html","hash":"743b2d8d60ca9c1b3e41b2181c0f05c7e0394a0f","modified":1480556096741},{"_id":"public/2016/08/28/从EventBus2-0-到-EventBus3-0/index.html","hash":"4b7bfdf241b9cee042b8bf187aa2bdc014e591d6","modified":1480556096741},{"_id":"public/2016/08/25/Rxjava学习：谈谈Rxjava的使用/index.html","hash":"1bcf0505c38167fe995e45f7c315592709ff35c0","modified":1480556096741},{"_id":"public/2016/08/18/hello-world/index.html","hash":"1628f1cf2779477e91999c963120ca104c1f91f6","modified":1480556096741},{"_id":"public/2016/08/23/Rxjava学习：初识Rxjava/index.html","hash":"7b4fa24a5b775d251b27ce10aeb0cdaa402cd65c","modified":1480556096741},{"_id":"public/2016/10/28/Android性能优化方法：内存泄露优化/index.html","hash":"33fac1bbf71ffd097172f954ae143ab2a21d899b","modified":1480556096741},{"_id":"public/index.html","hash":"f2fb435f9c85a0e65bfb2447e7d4beb7271deb19","modified":1480556096741},{"_id":"public/page/2/index.html","hash":"5bc0e939ccecc78b388f39676c55d416e6dd4baa","modified":1480556096741},{"_id":"public/2016/11/14/Retrofit2-1学习：Call接口的使用/index.html","hash":"626b08f0c587585397f2932922faeba5fdd881ec","modified":1480556096741},{"_id":"public/archives/2016/12/index.html","hash":"01cca47b9ea7467acbbd777a0bdc50ed75e5a85d","modified":1480556096749},{"_id":"public/tags/Notification/index.html","hash":"ca28b8d264e78ec84a8e600486b1fe8d727c6c10","modified":1480556096749},{"_id":"public/2016/12/01/消息栏通知Notification的那些事儿/index.html","hash":"e86692456d46f6a1a863f380242e30d3e656a16e","modified":1480556096749},{"_id":"public/imgs/2149115-a75ab976a221b88c.png","hash":"1a5255be24e7b26159c8633a09c4b31314a3f2a3","modified":1480556096749},{"_id":"public/imgs/4c1c8e5bfd6663f788acb9a9665f3ffc.jpg","hash":"267b7da18f54e50296af7cf94e9d36b2e00d3c14","modified":1480556096749},{"_id":"public/imgs/EventBus-Publish-Subscribe.png","hash":"78fd3a7b098edf5ae91a7b09fbedf7dc56ddda13","modified":1480556096749},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1480556096749},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1480556096749},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1480556096749},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1480556096749},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1480556096749},{"_id":"public/images/bitbug_favicon.ico","hash":"0f777bd8a0d2ac890d22e4fc13a1b3223faf7564","modified":1480556096749},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1480556096749},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1480556096749},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1480556096749},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1480556096750},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1480556096750},{"_id":"public/images/conon.jpg","hash":"81ffbd1712afe8cdf138b570c0fc9934742c33c1","modified":1480556096750},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1480556096750},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1480556096750},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1480556096750},{"_id":"public/VENS/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1480556096750},{"_id":"public/VENS/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1480556096750},{"_id":"public/VENS/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1480556096750},{"_id":"public/VENS/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1480556096750},{"_id":"public/VENS/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1480556096750},{"_id":"public/VENS/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1480556096750},{"_id":"public/VENS/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1480556096750},{"_id":"public/VENS/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1480556096750},{"_id":"public/VENS/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1480556096750},{"_id":"public/VENS/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1480556096750},{"_id":"public/VENS/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1480556099033},{"_id":"public/imgs/2149115-f2becc1a2a11fcfc.jpg","hash":"e9c7b5d947e52e0c3535f6f0bd5ec113c9493a56","modified":1480556099033},{"_id":"public/imgs/notification_01.png","hash":"0cc3affcebbb42cf3bdb121d20329b72c3a0acc0","modified":1480556099036},{"_id":"public/imgs/8c91ad2096d7aaea9dc52dc4c86a8d58.jpg","hash":"d68d1b9c5ba6d9b98783e5cfbe4558df22d7466b","modified":1480556099036},{"_id":"public/imgs/EventBus-Top.jpg","hash":"ddfe8d673801882b435c319331750ccb84719112","modified":1480556099036},{"_id":"public/imgs/notification_02.png","hash":"ff3084930996bf8bb5340561bae0e9cc36f4ef92","modified":1480556099036},{"_id":"public/imgs/notification_03.png","hash":"854ae9ca22b30cd2f0757d5025234ee6dd124591","modified":1480556099036},{"_id":"public/imgs/notification_04.png","hash":"18ada5a0a28a8d4867a8e4fcd7d7ca378243cd40","modified":1480556099036},{"_id":"public/VENS/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1480556099036},{"_id":"public/VENS/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1480556099036},{"_id":"public/VENS/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1480556099036},{"_id":"public/VENS/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1480556099039},{"_id":"public/VENS/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1480556099039},{"_id":"public/VENS/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1480556099039},{"_id":"public/VENS/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1480556099039},{"_id":"public/VENS/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1480556099039},{"_id":"public/VENS/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1480556099039},{"_id":"public/VENS/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1480556099039},{"_id":"public/VENS/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1480556099039},{"_id":"public/VENS/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1480556099039},{"_id":"public/VENS/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1480556099039},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1480556099039},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1480556099039},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1480556099039},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1480556099039},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1480556099039},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1480556099039},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1480556099039},{"_id":"public/VENS/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1480556099039},{"_id":"public/VENS/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1480556099039},{"_id":"public/VENS/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1480556099039},{"_id":"public/VENS/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1480556099039},{"_id":"public/VENS/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1480556099039},{"_id":"public/VENS/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1480556099039},{"_id":"public/VENS/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1480556099039},{"_id":"public/VENS/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1480556099039},{"_id":"public/VENS/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1480556099039},{"_id":"public/css/main.css","hash":"b24585779b56fc2c1a042213139250463efd1a20","modified":1480556099039},{"_id":"public/VENS/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1480556099039},{"_id":"public/VENS/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1480556099039},{"_id":"public/VENS/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1480556099040},{"_id":"public/VENS/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1480556099040},{"_id":"public/VENS/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1480556099040},{"_id":"public/VENS/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1480556099040},{"_id":"public/VENS/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1480556099040},{"_id":"public/VENS/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1480556099040},{"_id":"public/VENS/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1480556099040},{"_id":"public/VENS/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1480556099040},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1480556099041},{"_id":"public/VENS/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1480556099068}],"Category":[{"name":"Retrofit2.1","_id":"ciw5ovduo0004bqc622qo2t6l"},{"name":"android开发艺术谈说","_id":"ciw5ovdut0008bqc6x69uyhvi"},{"name":"Rxjava学习","_id":"ciw5ovdv0000ibqc634kpuwtn"},{"name":"EventBus","_id":"ciw5ovdv4000pbqc6k2kisqzx"},{"name":"Glide的使用","_id":"ciw5ovdv8000ybqc66ylr2icp"}],"Data":[],"Page":[{"layout":"true","title":"404","date":"2016-08-23T02:13:23.000Z","comments":0,"_content":"\n\n<script type=\"text/javascript\" src=\"https://www.qq.com/404/search_children.js\" charset=\"utf-8\" > \n\n","source":"404.md","raw":"---\nlayout: true\ntitle: 404\ndate: 2016-08-23 10:13:23\ncomments: false\n---\n\n\n<script type=\"text/javascript\" src=\"https://www.qq.com/404/search_children.js\" charset=\"utf-8\" > \n\n","updated":"2016-11-16T01:51:36.000Z","path":"404.html","_id":"ciw5ovduk0001bqc6be9v586b","content":"<script type=\"text/javascript\" src=\"https://www.qq.com/404/search_children.js\" charset=\"utf-8\"> \n\n</script>","excerpt":"","more":"<script type=\"text/javascript\" src=\"https://www.qq.com/404/search_children.js\" charset=\"utf-8\" > \n\n"},{"title":"about","date":"2016-08-23T02:13:23.000Z","type":"about","comments":0,"_content":"\n姓名：南柯Nanke\n\n所在地：北京朝阳\n\n从事行业：android移动端APP开发\n\n爱好：羽毛球\n\nqq: 791887271\n\n个人邮箱：vince_liu@aliyun.com\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"https://music.163.com/outchain/player?type=0&id=451103775&auto=1&height=430\"></iframe>","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-08-23 10:13:23\ntype: \"about\"\ncomments: false\n---\n\n姓名：南柯Nanke\n\n所在地：北京朝阳\n\n从事行业：android移动端APP开发\n\n爱好：羽毛球\n\nqq: 791887271\n\n个人邮箱：vince_liu@aliyun.com\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"https://music.163.com/outchain/player?type=0&id=451103775&auto=1&height=430\"></iframe>","updated":"2016-12-01T01:42:20.000Z","path":"about/index.html","_id":"ciw5ovdun0003bqc6ej5e12vt","layout":"page","content":"<p>姓名：南柯Nanke</p>\n<p>所在地：北京朝阳</p>\n<p>从事行业：android移动端APP开发</p>\n<p>爱好：羽毛球</p>\n<p>qq: 791887271</p>\n<p>个人邮箱：vince_liu@aliyun.com</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"450\" src=\"https://music.163.com/outchain/player?type=0&id=451103775&auto=1&height=430\"></iframe>","excerpt":"","more":"<p>姓名：南柯Nanke</p>\n<p>所在地：北京朝阳</p>\n<p>从事行业：android移动端APP开发</p>\n<p>爱好：羽毛球</p>\n<p>qq: 791887271</p>\n<p>个人邮箱：vince_liu@aliyun.com</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"https://music.163.com/outchain/player?type=0&id=451103775&auto=1&height=430\"></iframe>"},{"title":"tags","date":"2016-08-25T09:17:21.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-08-25 17:17:21\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-08-25T09:19:26.000Z","path":"tags/index.html","layout":"page","_id":"ciw5ovdvg001bbqc6p8g9mtvj","content":"","excerpt":"","more":""},{"title":"categories","date":"2016-08-25T09:14:43.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-08-25 17:14:43\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-08-25T09:18:50.000Z","path":"categories/index.html","layout":"page","_id":"ciw5ovdvu001cbqc6i1dm7542","content":"","excerpt":"","more":""}],"Post":[{"title":"Retrofit2.1学习:与Rxjava结合使用","date":"2016-11-11T01:54:39.000Z","_content":"\n### 前言：\n相对于Retrofit原始Call接口的使用，网上现在更多的是介绍与Rxjava相结合多使用，今天我们也来聊聊关于Rxjava的使用。\n<!-- more-->\n> 1.对Rxjava的引入\n\n首先需要导入 Rxjava 与 RxAndroid,以及Retrofit提供的适配接口\n```\ncompile 'io.reactivex:rxandroid:1.2.1'\ncompile 'io.reactivex:rxjava:1.1.8'\n\ncompile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'\n```\n\n接下来Retrofit对于Rxjava的适配做了封装，只需要一行代码就能完成引入。\n```\nRetrofit retrofit = new Retrofit.Builder().addConverterFactory(GsonConverterFactory.create())\n        .baseUrl(baseUrl)\n        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()).build();\n```\n\n> 2.Rxjava的结合使用\n\n接下来只需要对Retrofit需要转换的java接口进行修改。\n```\npublic interface ApiService {\n    @GET(\"list\")\n    Observable<Vo> getData();}\n```\n\n这样就完成了对Rxjava的整个引入，关于Rxjava的如何使用本文就不做重点介绍，如果大家想要了解 可以看看这篇文章 《[给 Android 开发者的 RxJava 详解](http://gank.io/post/560e15be2dca930e00da1083)》.\n","source":"_posts/Retrofit2-1学习-与Rxjava结合使用.md","raw":"---\ntitle: Retrofit2.1学习:与Rxjava结合使用\ndate: 2016-11-11 09:54:39\ntags:\ncategories: Retrofit2.1\n---\n\n### 前言：\n相对于Retrofit原始Call接口的使用，网上现在更多的是介绍与Rxjava相结合多使用，今天我们也来聊聊关于Rxjava的使用。\n<!-- more-->\n> 1.对Rxjava的引入\n\n首先需要导入 Rxjava 与 RxAndroid,以及Retrofit提供的适配接口\n```\ncompile 'io.reactivex:rxandroid:1.2.1'\ncompile 'io.reactivex:rxjava:1.1.8'\n\ncompile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'\n```\n\n接下来Retrofit对于Rxjava的适配做了封装，只需要一行代码就能完成引入。\n```\nRetrofit retrofit = new Retrofit.Builder().addConverterFactory(GsonConverterFactory.create())\n        .baseUrl(baseUrl)\n        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()).build();\n```\n\n> 2.Rxjava的结合使用\n\n接下来只需要对Retrofit需要转换的java接口进行修改。\n```\npublic interface ApiService {\n    @GET(\"list\")\n    Observable<Vo> getData();}\n```\n\n这样就完成了对Rxjava的整个引入，关于Rxjava的如何使用本文就不做重点介绍，如果大家想要了解 可以看看这篇文章 《[给 Android 开发者的 RxJava 详解](http://gank.io/post/560e15be2dca930e00da1083)》.\n","slug":"Retrofit2-1学习-与Rxjava结合使用","published":1,"updated":"2016-11-14T02:58:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovdug0000bqc6yborqxow","content":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>相对于Retrofit原始Call接口的使用，网上现在更多的是介绍与Rxjava相结合多使用，今天我们也来聊聊关于Rxjava的使用。<br><a id=\"more\"></a></p>\n<blockquote>\n<p>1.对Rxjava的引入</p>\n</blockquote>\n<p>首先需要导入 Rxjava 与 RxAndroid,以及Retrofit提供的适配接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile &apos;io.reactivex:rxandroid:1.2.1&apos;</div><div class=\"line\">compile &apos;io.reactivex:rxjava:1.1.8&apos;</div><div class=\"line\"></div><div class=\"line\">compile &apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;</div></pre></td></tr></table></figure></p>\n<p>接下来Retrofit对于Rxjava的适配做了封装，只需要一行代码就能完成引入。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Retrofit retrofit = new Retrofit.Builder().addConverterFactory(GsonConverterFactory.create())</div><div class=\"line\">        .baseUrl(baseUrl)</div><div class=\"line\">        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()).build();</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>2.Rxjava的结合使用</p>\n</blockquote>\n<p>接下来只需要对Retrofit需要转换的java接口进行修改。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface ApiService &#123;</div><div class=\"line\">    @GET(&quot;list&quot;)</div><div class=\"line\">    Observable&lt;Vo&gt; getData();&#125;</div></pre></td></tr></table></figure></p>\n<p>这样就完成了对Rxjava的整个引入，关于Rxjava的如何使用本文就不做重点介绍，如果大家想要了解 可以看看这篇文章 《<a href=\"http://gank.io/post/560e15be2dca930e00da1083\" target=\"_blank\" rel=\"external\">给 Android 开发者的 RxJava 详解</a>》.</p>\n","excerpt":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>相对于Retrofit原始Call接口的使用，网上现在更多的是介绍与Rxjava相结合多使用，今天我们也来聊聊关于Rxjava的使用。<br>","more":"</p>\n<blockquote>\n<p>1.对Rxjava的引入</p>\n</blockquote>\n<p>首先需要导入 Rxjava 与 RxAndroid,以及Retrofit提供的适配接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile &apos;io.reactivex:rxandroid:1.2.1&apos;</div><div class=\"line\">compile &apos;io.reactivex:rxjava:1.1.8&apos;</div><div class=\"line\"></div><div class=\"line\">compile &apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;</div></pre></td></tr></table></figure></p>\n<p>接下来Retrofit对于Rxjava的适配做了封装，只需要一行代码就能完成引入。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Retrofit retrofit = new Retrofit.Builder().addConverterFactory(GsonConverterFactory.create())</div><div class=\"line\">        .baseUrl(baseUrl)</div><div class=\"line\">        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()).build();</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>2.Rxjava的结合使用</p>\n</blockquote>\n<p>接下来只需要对Retrofit需要转换的java接口进行修改。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface ApiService &#123;</div><div class=\"line\">    @GET(&quot;list&quot;)</div><div class=\"line\">    Observable&lt;Vo&gt; getData();&#125;</div></pre></td></tr></table></figure></p>\n<p>这样就完成了对Rxjava的整个引入，关于Rxjava的如何使用本文就不做重点介绍，如果大家想要了解 可以看看这篇文章 《<a href=\"http://gank.io/post/560e15be2dca930e00da1083\">给 Android 开发者的 RxJava 详解</a>》.</p>"},{"title":"Android性能优化方法：内存泄露优化","date":"2016-10-28T07:29:15.000Z","_content":"\n### 前言\n内存泄露在开发工程中是一个需要重视的问题，但是由于内存泄露问题对开发人员的经验和开发意识有较高的要求，因此这也是开发人员最容易犯的错误之一。内存泄露的优化分为两个方面，一方面是在开发过程中避免写出有内存泄露的代码，另一方面是用过一些分析工具比如MAT来找出潜在的内存泄露的代码继而解决。本届主要介绍一些常见的内存泄露的例子，通过这些例子读者可以很好的理解内存泄露的发生场景并积累规避内存泄露的经验。\n<!-- more-->\n### 场景一：静态变量导致内存泄露\n\n下面这种情形是一种最简单的内存泄露，相信读者都不会这么干，下面代码将导致Activity无法正常销毁，一次静态变量sContext引用了它。\n```\npublic class MainActivity extends Activity {\n\tprivate static final String TAG = \"MainActivity\";\n\n\tprivate static Context sContext;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tsContext = this;\n\t}\n}\n```\n上面代码也可以改造一下，如下所示。sView是一个静态变量，它内部持有了当前Activity,所以Activity仍然无法释放。\n```\npublic class MainActivity extends Activity {\n\tprivate static final String TAG = \"MainActivity\";\n\n\tprivate static View sView;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tsView = new View(this);\n\t}\n}\n```\n### 场景2：单利模式导致的内存泄露\n静态变量导致的内存泄露都太过于明显，相信读者都不会犯这种错误，而单例模式所带来的内存泄露使我们容易忽视的，如下所示。首先提供一个单例模式的TestManager,TestManager 可以接受外部的注册并将外部的监听器储存起来。\n```\npublic class TestManager {\n\tprivate List<OnDataArrivedListener> mOnDataArrivedListeners = new ArrayList<OnDataArrivedListener>();\n\n\tprivate static class SingletonHolder {\n\t\tpublic static final TestManager INSTANCE = new TestManager();\n\t}\n\n\tprivate TestManager() {\n\t}\n\n\tpublic static TestManager getInstance() {\n\t\treturn SingletonHolder.INSTANCE;\n\t}\n\n\tpublic synchronized void registerListener(OnDataArrivedListener listener) {\n\t\tif (!mOnDataArrivedListeners.contains(listener)) {\n\t\t\tmOnDataArrivedListeners.add(listener);\n\t\t}\n\t}\n\n\tpublic synchronized void unregisterListener(OnDataArrivedListener listener) {\n\t\tif (mOnDataArrivedListeners.contains(listener)) {\n\t\t\tmOnDataArrivedListeners.remove(listener);\n\t\t}\n\t}\n\n\tinterface OnDataArrivedListener {\n\t\tpublic void onDataArrived(Object data);\n\t}\n}\n```\n接着再让Activity视线OnDataArrivedListener 接口并向TestManager注册监听，如下所示。下面的代码由于缺少解注册的曹锁所以会引起内存泄露，泄露的原因是Activity的对象被单例模式的TestManager所持有，而单例模式的特点是声明周期和Application保持一致，因此Activity对象无法被及时释放。\n```\npublic class MainActivity extends Activity implements OnDataArrivedListener{\n\tprivate static final String TAG = \"MainActivity\";\n\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tTestManager.getInstance().registerListener(this);\n\t}\n\n\t@Override\n\tpublic void onDataArrived(Object data) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n}\n```\n### 场景3：属性动画导致内存泄露\n从Android3.0开始，Google提供了属性动画，属性动画中有一类无线循环的动画，如果Activity中播放此类动画且没有在onDestory中去停止动画，那么动画会一直播放下去，尽管已经无法再界面上看到动画效果了，冰鞋这个时候Activity的View会被动画持有，而View又持有了Activity，导致最终Activity无法被释放。下面的动画就是无限动画，会泄露当前Activity,解决方法在Activity的onDestory中调用animator.cancel来停止动画。\n```\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tTestManager.getInstance().registerListener(this);\n\t\tButton button = (Button) findViewById(R.id.button);\n\t\tObjectAnimator animator = ObjectAnimator.ofFloat(button, \"rotation\", 0,\n\t\t\t\t360).setDuration(2000);\n\t\tanimator.setRepeatCount(ValueAnimator.INFINITE);\n\t\tanimator.start();\n\t}\n```\n\n### 一些性能优化建议\n- 避免创建过多的对象。\n- 不要过多使用枚举，枚举占用的内存空间要比整数大。\n- 常量请使用 static final 来修饰。\n- 使用一些Android特有的数据结构，比如SparseArray和Pair等，他们都具有更好地性能。\n- 适当使用软引用和弱引用。\n- 采用内存缓存和磁盘缓存。\n- 尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露。\n","source":"_posts/Android性能优化方法：内存泄露优化.md","raw":"---\ntitle: Android性能优化方法：内存泄露优化\ndate: 2016-10-28 15:29:15\ntags:\ncategories: android开发艺术谈说\n---\n\n### 前言\n内存泄露在开发工程中是一个需要重视的问题，但是由于内存泄露问题对开发人员的经验和开发意识有较高的要求，因此这也是开发人员最容易犯的错误之一。内存泄露的优化分为两个方面，一方面是在开发过程中避免写出有内存泄露的代码，另一方面是用过一些分析工具比如MAT来找出潜在的内存泄露的代码继而解决。本届主要介绍一些常见的内存泄露的例子，通过这些例子读者可以很好的理解内存泄露的发生场景并积累规避内存泄露的经验。\n<!-- more-->\n### 场景一：静态变量导致内存泄露\n\n下面这种情形是一种最简单的内存泄露，相信读者都不会这么干，下面代码将导致Activity无法正常销毁，一次静态变量sContext引用了它。\n```\npublic class MainActivity extends Activity {\n\tprivate static final String TAG = \"MainActivity\";\n\n\tprivate static Context sContext;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tsContext = this;\n\t}\n}\n```\n上面代码也可以改造一下，如下所示。sView是一个静态变量，它内部持有了当前Activity,所以Activity仍然无法释放。\n```\npublic class MainActivity extends Activity {\n\tprivate static final String TAG = \"MainActivity\";\n\n\tprivate static View sView;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tsView = new View(this);\n\t}\n}\n```\n### 场景2：单利模式导致的内存泄露\n静态变量导致的内存泄露都太过于明显，相信读者都不会犯这种错误，而单例模式所带来的内存泄露使我们容易忽视的，如下所示。首先提供一个单例模式的TestManager,TestManager 可以接受外部的注册并将外部的监听器储存起来。\n```\npublic class TestManager {\n\tprivate List<OnDataArrivedListener> mOnDataArrivedListeners = new ArrayList<OnDataArrivedListener>();\n\n\tprivate static class SingletonHolder {\n\t\tpublic static final TestManager INSTANCE = new TestManager();\n\t}\n\n\tprivate TestManager() {\n\t}\n\n\tpublic static TestManager getInstance() {\n\t\treturn SingletonHolder.INSTANCE;\n\t}\n\n\tpublic synchronized void registerListener(OnDataArrivedListener listener) {\n\t\tif (!mOnDataArrivedListeners.contains(listener)) {\n\t\t\tmOnDataArrivedListeners.add(listener);\n\t\t}\n\t}\n\n\tpublic synchronized void unregisterListener(OnDataArrivedListener listener) {\n\t\tif (mOnDataArrivedListeners.contains(listener)) {\n\t\t\tmOnDataArrivedListeners.remove(listener);\n\t\t}\n\t}\n\n\tinterface OnDataArrivedListener {\n\t\tpublic void onDataArrived(Object data);\n\t}\n}\n```\n接着再让Activity视线OnDataArrivedListener 接口并向TestManager注册监听，如下所示。下面的代码由于缺少解注册的曹锁所以会引起内存泄露，泄露的原因是Activity的对象被单例模式的TestManager所持有，而单例模式的特点是声明周期和Application保持一致，因此Activity对象无法被及时释放。\n```\npublic class MainActivity extends Activity implements OnDataArrivedListener{\n\tprivate static final String TAG = \"MainActivity\";\n\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tTestManager.getInstance().registerListener(this);\n\t}\n\n\t@Override\n\tpublic void onDataArrived(Object data) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n}\n```\n### 场景3：属性动画导致内存泄露\n从Android3.0开始，Google提供了属性动画，属性动画中有一类无线循环的动画，如果Activity中播放此类动画且没有在onDestory中去停止动画，那么动画会一直播放下去，尽管已经无法再界面上看到动画效果了，冰鞋这个时候Activity的View会被动画持有，而View又持有了Activity，导致最终Activity无法被释放。下面的动画就是无限动画，会泄露当前Activity,解决方法在Activity的onDestory中调用animator.cancel来停止动画。\n```\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tTestManager.getInstance().registerListener(this);\n\t\tButton button = (Button) findViewById(R.id.button);\n\t\tObjectAnimator animator = ObjectAnimator.ofFloat(button, \"rotation\", 0,\n\t\t\t\t360).setDuration(2000);\n\t\tanimator.setRepeatCount(ValueAnimator.INFINITE);\n\t\tanimator.start();\n\t}\n```\n\n### 一些性能优化建议\n- 避免创建过多的对象。\n- 不要过多使用枚举，枚举占用的内存空间要比整数大。\n- 常量请使用 static final 来修饰。\n- 使用一些Android特有的数据结构，比如SparseArray和Pair等，他们都具有更好地性能。\n- 适当使用软引用和弱引用。\n- 采用内存缓存和磁盘缓存。\n- 尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露。\n","slug":"Android性能优化方法：内存泄露优化","published":1,"updated":"2016-11-11T01:56:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovdul0002bqc6us2la7w5","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>内存泄露在开发工程中是一个需要重视的问题，但是由于内存泄露问题对开发人员的经验和开发意识有较高的要求，因此这也是开发人员最容易犯的错误之一。内存泄露的优化分为两个方面，一方面是在开发过程中避免写出有内存泄露的代码，另一方面是用过一些分析工具比如MAT来找出潜在的内存泄露的代码继而解决。本届主要介绍一些常见的内存泄露的例子，通过这些例子读者可以很好的理解内存泄露的发生场景并积累规避内存泄露的经验。<br><a id=\"more\"></a></p>\n<h3 id=\"场景一：静态变量导致内存泄露\"><a href=\"#场景一：静态变量导致内存泄露\" class=\"headerlink\" title=\"场景一：静态变量导致内存泄露\"></a>场景一：静态变量导致内存泄露</h3><p>下面这种情形是一种最简单的内存泄露，相信读者都不会这么干，下面代码将导致Activity无法正常销毁，一次静态变量sContext引用了它。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends Activity &#123;</div><div class=\"line\">\tprivate static final String TAG = &quot;MainActivity&quot;;</div><div class=\"line\"></div><div class=\"line\">\tprivate static Context sContext;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">\t\tsuper.onCreate(savedInstanceState);</div><div class=\"line\">\t\tsetContentView(R.layout.activity_main);</div><div class=\"line\">\t\tsContext = this;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面代码也可以改造一下，如下所示。sView是一个静态变量，它内部持有了当前Activity,所以Activity仍然无法释放。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends Activity &#123;</div><div class=\"line\">\tprivate static final String TAG = &quot;MainActivity&quot;;</div><div class=\"line\"></div><div class=\"line\">\tprivate static View sView;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">\t\tsuper.onCreate(savedInstanceState);</div><div class=\"line\">\t\tsetContentView(R.layout.activity_main);</div><div class=\"line\">\t\tsView = new View(this);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"场景2：单利模式导致的内存泄露\"><a href=\"#场景2：单利模式导致的内存泄露\" class=\"headerlink\" title=\"场景2：单利模式导致的内存泄露\"></a>场景2：单利模式导致的内存泄露</h3><p>静态变量导致的内存泄露都太过于明显，相信读者都不会犯这种错误，而单例模式所带来的内存泄露使我们容易忽视的，如下所示。首先提供一个单例模式的TestManager,TestManager 可以接受外部的注册并将外部的监听器储存起来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TestManager &#123;</div><div class=\"line\">\tprivate List&lt;OnDataArrivedListener&gt; mOnDataArrivedListeners = new ArrayList&lt;OnDataArrivedListener&gt;();</div><div class=\"line\"></div><div class=\"line\">\tprivate static class SingletonHolder &#123;</div><div class=\"line\">\t\tpublic static final TestManager INSTANCE = new TestManager();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tprivate TestManager() &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic static TestManager getInstance() &#123;</div><div class=\"line\">\t\treturn SingletonHolder.INSTANCE;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic synchronized void registerListener(OnDataArrivedListener listener) &#123;</div><div class=\"line\">\t\tif (!mOnDataArrivedListeners.contains(listener)) &#123;</div><div class=\"line\">\t\t\tmOnDataArrivedListeners.add(listener);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic synchronized void unregisterListener(OnDataArrivedListener listener) &#123;</div><div class=\"line\">\t\tif (mOnDataArrivedListeners.contains(listener)) &#123;</div><div class=\"line\">\t\t\tmOnDataArrivedListeners.remove(listener);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tinterface OnDataArrivedListener &#123;</div><div class=\"line\">\t\tpublic void onDataArrived(Object data);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接着再让Activity视线OnDataArrivedListener 接口并向TestManager注册监听，如下所示。下面的代码由于缺少解注册的曹锁所以会引起内存泄露，泄露的原因是Activity的对象被单例模式的TestManager所持有，而单例模式的特点是声明周期和Application保持一致，因此Activity对象无法被及时释放。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends Activity implements OnDataArrivedListener&#123;</div><div class=\"line\">\tprivate static final String TAG = &quot;MainActivity&quot;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">\t\tsuper.onCreate(savedInstanceState);</div><div class=\"line\">\t\tsetContentView(R.layout.activity_main);</div><div class=\"line\">\t\tTestManager.getInstance().registerListener(this);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void onDataArrived(Object data) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"场景3：属性动画导致内存泄露\"><a href=\"#场景3：属性动画导致内存泄露\" class=\"headerlink\" title=\"场景3：属性动画导致内存泄露\"></a>场景3：属性动画导致内存泄露</h3><p>从Android3.0开始，Google提供了属性动画，属性动画中有一类无线循环的动画，如果Activity中播放此类动画且没有在onDestory中去停止动画，那么动画会一直播放下去，尽管已经无法再界面上看到动画效果了，冰鞋这个时候Activity的View会被动画持有，而View又持有了Activity，导致最终Activity无法被释放。下面的动画就是无限动画，会泄露当前Activity,解决方法在Activity的onDestory中调用animator.cancel来停止动画。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">\tsuper.onCreate(savedInstanceState);</div><div class=\"line\">\tsetContentView(R.layout.activity_main);</div><div class=\"line\">\tTestManager.getInstance().registerListener(this);</div><div class=\"line\">\tButton button = (Button) findViewById(R.id.button);</div><div class=\"line\">\tObjectAnimator animator = ObjectAnimator.ofFloat(button, &quot;rotation&quot;, 0,</div><div class=\"line\">\t\t\t360).setDuration(2000);</div><div class=\"line\">\tanimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class=\"line\">\tanimator.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"一些性能优化建议\"><a href=\"#一些性能优化建议\" class=\"headerlink\" title=\"一些性能优化建议\"></a>一些性能优化建议</h3><ul>\n<li>避免创建过多的对象。</li>\n<li>不要过多使用枚举，枚举占用的内存空间要比整数大。</li>\n<li>常量请使用 static final 来修饰。</li>\n<li>使用一些Android特有的数据结构，比如SparseArray和Pair等，他们都具有更好地性能。</li>\n<li>适当使用软引用和弱引用。</li>\n<li>采用内存缓存和磁盘缓存。</li>\n<li>尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露。</li>\n</ul>\n","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>内存泄露在开发工程中是一个需要重视的问题，但是由于内存泄露问题对开发人员的经验和开发意识有较高的要求，因此这也是开发人员最容易犯的错误之一。内存泄露的优化分为两个方面，一方面是在开发过程中避免写出有内存泄露的代码，另一方面是用过一些分析工具比如MAT来找出潜在的内存泄露的代码继而解决。本届主要介绍一些常见的内存泄露的例子，通过这些例子读者可以很好的理解内存泄露的发生场景并积累规避内存泄露的经验。<br>","more":"</p>\n<h3 id=\"场景一：静态变量导致内存泄露\"><a href=\"#场景一：静态变量导致内存泄露\" class=\"headerlink\" title=\"场景一：静态变量导致内存泄露\"></a>场景一：静态变量导致内存泄露</h3><p>下面这种情形是一种最简单的内存泄露，相信读者都不会这么干，下面代码将导致Activity无法正常销毁，一次静态变量sContext引用了它。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends Activity &#123;</div><div class=\"line\">\tprivate static final String TAG = &quot;MainActivity&quot;;</div><div class=\"line\"></div><div class=\"line\">\tprivate static Context sContext;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">\t\tsuper.onCreate(savedInstanceState);</div><div class=\"line\">\t\tsetContentView(R.layout.activity_main);</div><div class=\"line\">\t\tsContext = this;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面代码也可以改造一下，如下所示。sView是一个静态变量，它内部持有了当前Activity,所以Activity仍然无法释放。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends Activity &#123;</div><div class=\"line\">\tprivate static final String TAG = &quot;MainActivity&quot;;</div><div class=\"line\"></div><div class=\"line\">\tprivate static View sView;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">\t\tsuper.onCreate(savedInstanceState);</div><div class=\"line\">\t\tsetContentView(R.layout.activity_main);</div><div class=\"line\">\t\tsView = new View(this);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"场景2：单利模式导致的内存泄露\"><a href=\"#场景2：单利模式导致的内存泄露\" class=\"headerlink\" title=\"场景2：单利模式导致的内存泄露\"></a>场景2：单利模式导致的内存泄露</h3><p>静态变量导致的内存泄露都太过于明显，相信读者都不会犯这种错误，而单例模式所带来的内存泄露使我们容易忽视的，如下所示。首先提供一个单例模式的TestManager,TestManager 可以接受外部的注册并将外部的监听器储存起来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TestManager &#123;</div><div class=\"line\">\tprivate List&lt;OnDataArrivedListener&gt; mOnDataArrivedListeners = new ArrayList&lt;OnDataArrivedListener&gt;();</div><div class=\"line\"></div><div class=\"line\">\tprivate static class SingletonHolder &#123;</div><div class=\"line\">\t\tpublic static final TestManager INSTANCE = new TestManager();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tprivate TestManager() &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic static TestManager getInstance() &#123;</div><div class=\"line\">\t\treturn SingletonHolder.INSTANCE;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic synchronized void registerListener(OnDataArrivedListener listener) &#123;</div><div class=\"line\">\t\tif (!mOnDataArrivedListeners.contains(listener)) &#123;</div><div class=\"line\">\t\t\tmOnDataArrivedListeners.add(listener);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic synchronized void unregisterListener(OnDataArrivedListener listener) &#123;</div><div class=\"line\">\t\tif (mOnDataArrivedListeners.contains(listener)) &#123;</div><div class=\"line\">\t\t\tmOnDataArrivedListeners.remove(listener);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tinterface OnDataArrivedListener &#123;</div><div class=\"line\">\t\tpublic void onDataArrived(Object data);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接着再让Activity视线OnDataArrivedListener 接口并向TestManager注册监听，如下所示。下面的代码由于缺少解注册的曹锁所以会引起内存泄露，泄露的原因是Activity的对象被单例模式的TestManager所持有，而单例模式的特点是声明周期和Application保持一致，因此Activity对象无法被及时释放。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends Activity implements OnDataArrivedListener&#123;</div><div class=\"line\">\tprivate static final String TAG = &quot;MainActivity&quot;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">\t\tsuper.onCreate(savedInstanceState);</div><div class=\"line\">\t\tsetContentView(R.layout.activity_main);</div><div class=\"line\">\t\tTestManager.getInstance().registerListener(this);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void onDataArrived(Object data) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"场景3：属性动画导致内存泄露\"><a href=\"#场景3：属性动画导致内存泄露\" class=\"headerlink\" title=\"场景3：属性动画导致内存泄露\"></a>场景3：属性动画导致内存泄露</h3><p>从Android3.0开始，Google提供了属性动画，属性动画中有一类无线循环的动画，如果Activity中播放此类动画且没有在onDestory中去停止动画，那么动画会一直播放下去，尽管已经无法再界面上看到动画效果了，冰鞋这个时候Activity的View会被动画持有，而View又持有了Activity，导致最终Activity无法被释放。下面的动画就是无限动画，会泄露当前Activity,解决方法在Activity的onDestory中调用animator.cancel来停止动画。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">\tsuper.onCreate(savedInstanceState);</div><div class=\"line\">\tsetContentView(R.layout.activity_main);</div><div class=\"line\">\tTestManager.getInstance().registerListener(this);</div><div class=\"line\">\tButton button = (Button) findViewById(R.id.button);</div><div class=\"line\">\tObjectAnimator animator = ObjectAnimator.ofFloat(button, &quot;rotation&quot;, 0,</div><div class=\"line\">\t\t\t360).setDuration(2000);</div><div class=\"line\">\tanimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class=\"line\">\tanimator.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"一些性能优化建议\"><a href=\"#一些性能优化建议\" class=\"headerlink\" title=\"一些性能优化建议\"></a>一些性能优化建议</h3><ul>\n<li>避免创建过多的对象。</li>\n<li>不要过多使用枚举，枚举占用的内存空间要比整数大。</li>\n<li>常量请使用 static final 来修饰。</li>\n<li>使用一些Android特有的数据结构，比如SparseArray和Pair等，他们都具有更好地性能。</li>\n<li>适当使用软引用和弱引用。</li>\n<li>采用内存缓存和磁盘缓存。</li>\n<li>尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露。</li>\n</ul>"},{"title":"Retrofit2.1学习：Call接口的使用","date":"2016-11-14T07:33:37.000Z","_content":"\n#### 前言：\n  前面提到 [Retrofit与Rxjava 的结合使用]() ,今天我们就来说一说Retrofit原生自带的Call接口的使用,本文主要针对Retrofit 2.0 的开发使用，对于2.0之前的版本的使用不做讨论。\n<!-- more-->\n#### 添加INTERNET权限\n```\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n在Retrofit 2.0中，当你调用call.enqueue或者call.execute，未添加权限，将立即抛出SecurityException，如果你不使用try-catch会导致崩溃。\n\n#### Call 接口的实例化\n\n```\npublic interface GitHubService {\n  @GET(\"list\")\n  Call<List<Repo>> listRepos();\n}\n```\n创建service 的方法和OkHttp的模式一模一样。\n\n```\nGitHubService service = retrofit.create(GitHubService.class);\n```\n\n如果要调用同步请求，只需调用execute；而发起一个异步请求则是调用enqueue。\n\n#### 同步请求\n```\nCall<List<Repo>> call = service. listRepos();\nList<Repo> repo = call.execute();\n```\n\n以上的代码会阻塞线程，因此你不能在安卓的主线程中调用，不然会面临NetworkOnMainThreadException。如果你想调用execute方法，请在开启子线程执行。\n\n#### 异步请求\n```\nCall<Repo> call = service.listRepos(\"user\");\ncall.enqueue(new Callback<Repo>() {\n    @Override\n    public void onResponse(Call<List<Repo>> call,Response<List<Repo>> response) {\n        // Get result Repo from response.body()\n    }\n \n    @Override\n    public void onFailure(Call<List<Repo>> call,Throwable t) {\n \n    }\n});\n```\n以上代码发起了一个在后台线程的请求并从response 的response.body()方法中获取一个结果对象。注意这里的onResponse和onFailure方法是在主线程中调用的。\n\n这里建议你使用enqueue，它最符合 Android OS的习惯。\n\n#### 取消正在进行中的业务\n\nservice 的模式变成Call的形式的原因是为了让正在进行的事务可以被取消。要做到这点，你只需调用call.cancel()。\n```\ncall.cancel();\n```\n\n#### Callback 回调的使用\n\nonResponse的调用，不仅仅是成功返回结果时调用，存在问题时也会被调用，这里查看了很多关于出现这个问题的解决方法，然而并没有给出一个明确的方案，之后查看了一下Retrofit2.0 提供的官方API解释，如下：\n\n> An HTTP response may still indicate an application-level failure such as a 404 or 500. Call Response.isSuccessful() to determine if the response indicates success.\nHTTP response 仍然可以指示应用程序级故障，如404或500。调用Response.isSuccessful()，以确定是否该响应指示成功。\n\n```\n@Override\n    public void onResponse(Call<List<Repo>> call,Response<List<Repo>> response) {\n        // Get result Repo from response.body()\n       if(response.isSuccessful()){\n           List<Repo> repos = response.body();\n          //对数据的处理操作\n       }else{\n        //请求出现错误例如：404 或者 500\n       }\n    }\n```\n\n而关于 onFailure方法的调用，网上也并没有给出明确的调用时机，而官方文档给出解释：\n>Invoked when a network exception occurred talking to the server or when an unexpected exception occurred creating the request or processing the response.\n当连接服务器时出现网络异常 或者 在创建请求、处理响应结果 的时候突发异常 都会被调用。\n\n通过自己测试发现了几种调用情况：**GSON解析数据转换错误**，**手机断网或者网络异常**。\n\n```\n    @Override\n    public void onFailure(Call<List<Repo>> call,Throwable t) {\n      \n    }\n```","source":"_posts/Retrofit2-1学习：Call接口的使用.md","raw":"---\ntitle: Retrofit2.1学习：Call接口的使用\ndate: 2016-11-14 15:33:37\ntags:\ncategories: Retrofit2.1\n---\n\n#### 前言：\n  前面提到 [Retrofit与Rxjava 的结合使用]() ,今天我们就来说一说Retrofit原生自带的Call接口的使用,本文主要针对Retrofit 2.0 的开发使用，对于2.0之前的版本的使用不做讨论。\n<!-- more-->\n#### 添加INTERNET权限\n```\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n在Retrofit 2.0中，当你调用call.enqueue或者call.execute，未添加权限，将立即抛出SecurityException，如果你不使用try-catch会导致崩溃。\n\n#### Call 接口的实例化\n\n```\npublic interface GitHubService {\n  @GET(\"list\")\n  Call<List<Repo>> listRepos();\n}\n```\n创建service 的方法和OkHttp的模式一模一样。\n\n```\nGitHubService service = retrofit.create(GitHubService.class);\n```\n\n如果要调用同步请求，只需调用execute；而发起一个异步请求则是调用enqueue。\n\n#### 同步请求\n```\nCall<List<Repo>> call = service. listRepos();\nList<Repo> repo = call.execute();\n```\n\n以上的代码会阻塞线程，因此你不能在安卓的主线程中调用，不然会面临NetworkOnMainThreadException。如果你想调用execute方法，请在开启子线程执行。\n\n#### 异步请求\n```\nCall<Repo> call = service.listRepos(\"user\");\ncall.enqueue(new Callback<Repo>() {\n    @Override\n    public void onResponse(Call<List<Repo>> call,Response<List<Repo>> response) {\n        // Get result Repo from response.body()\n    }\n \n    @Override\n    public void onFailure(Call<List<Repo>> call,Throwable t) {\n \n    }\n});\n```\n以上代码发起了一个在后台线程的请求并从response 的response.body()方法中获取一个结果对象。注意这里的onResponse和onFailure方法是在主线程中调用的。\n\n这里建议你使用enqueue，它最符合 Android OS的习惯。\n\n#### 取消正在进行中的业务\n\nservice 的模式变成Call的形式的原因是为了让正在进行的事务可以被取消。要做到这点，你只需调用call.cancel()。\n```\ncall.cancel();\n```\n\n#### Callback 回调的使用\n\nonResponse的调用，不仅仅是成功返回结果时调用，存在问题时也会被调用，这里查看了很多关于出现这个问题的解决方法，然而并没有给出一个明确的方案，之后查看了一下Retrofit2.0 提供的官方API解释，如下：\n\n> An HTTP response may still indicate an application-level failure such as a 404 or 500. Call Response.isSuccessful() to determine if the response indicates success.\nHTTP response 仍然可以指示应用程序级故障，如404或500。调用Response.isSuccessful()，以确定是否该响应指示成功。\n\n```\n@Override\n    public void onResponse(Call<List<Repo>> call,Response<List<Repo>> response) {\n        // Get result Repo from response.body()\n       if(response.isSuccessful()){\n           List<Repo> repos = response.body();\n          //对数据的处理操作\n       }else{\n        //请求出现错误例如：404 或者 500\n       }\n    }\n```\n\n而关于 onFailure方法的调用，网上也并没有给出明确的调用时机，而官方文档给出解释：\n>Invoked when a network exception occurred talking to the server or when an unexpected exception occurred creating the request or processing the response.\n当连接服务器时出现网络异常 或者 在创建请求、处理响应结果 的时候突发异常 都会被调用。\n\n通过自己测试发现了几种调用情况：**GSON解析数据转换错误**，**手机断网或者网络异常**。\n\n```\n    @Override\n    public void onFailure(Call<List<Repo>> call,Throwable t) {\n      \n    }\n```","slug":"Retrofit2-1学习：Call接口的使用","published":1,"updated":"2016-11-14T07:35:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovdur0005bqc6g3hfn6u4","content":"<h4 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h4><p>  前面提到 <a href=\"\">Retrofit与Rxjava 的结合使用</a> ,今天我们就来说一说Retrofit原生自带的Call接口的使用,本文主要针对Retrofit 2.0 的开发使用，对于2.0之前的版本的使用不做讨论。<br><a id=\"more\"></a></p>\n<h4 id=\"添加INTERNET权限\"><a href=\"#添加INTERNET权限\" class=\"headerlink\" title=\"添加INTERNET权限\"></a>添加INTERNET权限</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>在Retrofit 2.0中，当你调用call.enqueue或者call.execute，未添加权限，将立即抛出SecurityException，如果你不使用try-catch会导致崩溃。</p>\n<h4 id=\"Call-接口的实例化\"><a href=\"#Call-接口的实例化\" class=\"headerlink\" title=\"Call 接口的实例化\"></a>Call 接口的实例化</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface GitHubService &#123;</div><div class=\"line\">  @GET(&quot;list&quot;)</div><div class=\"line\">  Call&lt;List&lt;Repo&gt;&gt; listRepos();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建service 的方法和OkHttp的模式一模一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure>\n<p>如果要调用同步请求，只需调用execute；而发起一个异步请求则是调用enqueue。</p>\n<h4 id=\"同步请求\"><a href=\"#同步请求\" class=\"headerlink\" title=\"同步请求\"></a>同步请求</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Call&lt;List&lt;Repo&gt;&gt; call = service. listRepos();</div><div class=\"line\">List&lt;Repo&gt; repo = call.execute();</div></pre></td></tr></table></figure>\n<p>以上的代码会阻塞线程，因此你不能在安卓的主线程中调用，不然会面临NetworkOnMainThreadException。如果你想调用execute方法，请在开启子线程执行。</p>\n<h4 id=\"异步请求\"><a href=\"#异步请求\" class=\"headerlink\" title=\"异步请求\"></a>异步请求</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Call&lt;Repo&gt; call = service.listRepos(&quot;user&quot;);</div><div class=\"line\">call.enqueue(new Callback&lt;Repo&gt;() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call,Response&lt;List&lt;Repo&gt;&gt; response) &#123;</div><div class=\"line\">        // Get result Repo from response.body()</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    @Override</div><div class=\"line\">    public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call,Throwable t) &#123;</div><div class=\"line\"> </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>以上代码发起了一个在后台线程的请求并从response 的response.body()方法中获取一个结果对象。注意这里的onResponse和onFailure方法是在主线程中调用的。</p>\n<p>这里建议你使用enqueue，它最符合 Android OS的习惯。</p>\n<h4 id=\"取消正在进行中的业务\"><a href=\"#取消正在进行中的业务\" class=\"headerlink\" title=\"取消正在进行中的业务\"></a>取消正在进行中的业务</h4><p>service 的模式变成Call的形式的原因是为了让正在进行的事务可以被取消。要做到这点，你只需调用call.cancel()。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">call.cancel();</div></pre></td></tr></table></figure></p>\n<h4 id=\"Callback-回调的使用\"><a href=\"#Callback-回调的使用\" class=\"headerlink\" title=\"Callback 回调的使用\"></a>Callback 回调的使用</h4><p>onResponse的调用，不仅仅是成功返回结果时调用，存在问题时也会被调用，这里查看了很多关于出现这个问题的解决方法，然而并没有给出一个明确的方案，之后查看了一下Retrofit2.0 提供的官方API解释，如下：</p>\n<blockquote>\n<p>An HTTP response may still indicate an application-level failure such as a 404 or 500. Call Response.isSuccessful() to determine if the response indicates success.<br>HTTP response 仍然可以指示应用程序级故障，如404或500。调用Response.isSuccessful()，以确定是否该响应指示成功。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call,Response&lt;List&lt;Repo&gt;&gt; response) &#123;</div><div class=\"line\">        // Get result Repo from response.body()</div><div class=\"line\">       if(response.isSuccessful())&#123;</div><div class=\"line\">           List&lt;Repo&gt; repos = response.body();</div><div class=\"line\">          //对数据的处理操作</div><div class=\"line\">       &#125;else&#123;</div><div class=\"line\">        //请求出现错误例如：404 或者 500</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>而关于 onFailure方法的调用，网上也并没有给出明确的调用时机，而官方文档给出解释：</p>\n<blockquote>\n<p>Invoked when a network exception occurred talking to the server or when an unexpected exception occurred creating the request or processing the response.<br>当连接服务器时出现网络异常 或者 在创建请求、处理响应结果 的时候突发异常 都会被调用。</p>\n</blockquote>\n<p>通过自己测试发现了几种调用情况：<strong>GSON解析数据转换错误</strong>，<strong>手机断网或者网络异常</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call,Throwable t) &#123;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<h4 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h4><p>  前面提到 <a href=\"\">Retrofit与Rxjava 的结合使用</a> ,今天我们就来说一说Retrofit原生自带的Call接口的使用,本文主要针对Retrofit 2.0 的开发使用，对于2.0之前的版本的使用不做讨论。<br>","more":"</p>\n<h4 id=\"添加INTERNET权限\"><a href=\"#添加INTERNET权限\" class=\"headerlink\" title=\"添加INTERNET权限\"></a>添加INTERNET权限</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>在Retrofit 2.0中，当你调用call.enqueue或者call.execute，未添加权限，将立即抛出SecurityException，如果你不使用try-catch会导致崩溃。</p>\n<h4 id=\"Call-接口的实例化\"><a href=\"#Call-接口的实例化\" class=\"headerlink\" title=\"Call 接口的实例化\"></a>Call 接口的实例化</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface GitHubService &#123;</div><div class=\"line\">  @GET(&quot;list&quot;)</div><div class=\"line\">  Call&lt;List&lt;Repo&gt;&gt; listRepos();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建service 的方法和OkHttp的模式一模一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure>\n<p>如果要调用同步请求，只需调用execute；而发起一个异步请求则是调用enqueue。</p>\n<h4 id=\"同步请求\"><a href=\"#同步请求\" class=\"headerlink\" title=\"同步请求\"></a>同步请求</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Call&lt;List&lt;Repo&gt;&gt; call = service. listRepos();</div><div class=\"line\">List&lt;Repo&gt; repo = call.execute();</div></pre></td></tr></table></figure>\n<p>以上的代码会阻塞线程，因此你不能在安卓的主线程中调用，不然会面临NetworkOnMainThreadException。如果你想调用execute方法，请在开启子线程执行。</p>\n<h4 id=\"异步请求\"><a href=\"#异步请求\" class=\"headerlink\" title=\"异步请求\"></a>异步请求</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Call&lt;Repo&gt; call = service.listRepos(&quot;user&quot;);</div><div class=\"line\">call.enqueue(new Callback&lt;Repo&gt;() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call,Response&lt;List&lt;Repo&gt;&gt; response) &#123;</div><div class=\"line\">        // Get result Repo from response.body()</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    @Override</div><div class=\"line\">    public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call,Throwable t) &#123;</div><div class=\"line\"> </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>以上代码发起了一个在后台线程的请求并从response 的response.body()方法中获取一个结果对象。注意这里的onResponse和onFailure方法是在主线程中调用的。</p>\n<p>这里建议你使用enqueue，它最符合 Android OS的习惯。</p>\n<h4 id=\"取消正在进行中的业务\"><a href=\"#取消正在进行中的业务\" class=\"headerlink\" title=\"取消正在进行中的业务\"></a>取消正在进行中的业务</h4><p>service 的模式变成Call的形式的原因是为了让正在进行的事务可以被取消。要做到这点，你只需调用call.cancel()。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">call.cancel();</div></pre></td></tr></table></figure></p>\n<h4 id=\"Callback-回调的使用\"><a href=\"#Callback-回调的使用\" class=\"headerlink\" title=\"Callback 回调的使用\"></a>Callback 回调的使用</h4><p>onResponse的调用，不仅仅是成功返回结果时调用，存在问题时也会被调用，这里查看了很多关于出现这个问题的解决方法，然而并没有给出一个明确的方案，之后查看了一下Retrofit2.0 提供的官方API解释，如下：</p>\n<blockquote>\n<p>An HTTP response may still indicate an application-level failure such as a 404 or 500. Call Response.isSuccessful() to determine if the response indicates success.<br>HTTP response 仍然可以指示应用程序级故障，如404或500。调用Response.isSuccessful()，以确定是否该响应指示成功。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call,Response&lt;List&lt;Repo&gt;&gt; response) &#123;</div><div class=\"line\">        // Get result Repo from response.body()</div><div class=\"line\">       if(response.isSuccessful())&#123;</div><div class=\"line\">           List&lt;Repo&gt; repos = response.body();</div><div class=\"line\">          //对数据的处理操作</div><div class=\"line\">       &#125;else&#123;</div><div class=\"line\">        //请求出现错误例如：404 或者 500</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>而关于 onFailure方法的调用，网上也并没有给出明确的调用时机，而官方文档给出解释：</p>\n<blockquote>\n<p>Invoked when a network exception occurred talking to the server or when an unexpected exception occurred creating the request or processing the response.<br>当连接服务器时出现网络异常 或者 在创建请求、处理响应结果 的时候突发异常 都会被调用。</p>\n</blockquote>\n<p>通过自己测试发现了几种调用情况：<strong>GSON解析数据转换错误</strong>，<strong>手机断网或者网络异常</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call,Throwable t) &#123;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Retrofit2.1学习:与okhttp3.0结合使用","date":"2016-10-31T01:15:36.000Z","_content":"![配图](/imgs/2149115-f2becc1a2a11fcfc.jpg)\n\n### 1.添加日志输出\n\n\n```\nRetrofit retrofit = new Retrofit.Builder().client(new OkHttpClient.Builder().addNetworkInterceptor(\n   new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.HEADERS)).build());\n```\n<!-- more-->\n***\n### 2.添加请求头信息\n\n在 [Retrofit官方文档的翻译](http://www.jianshu.com/p/8cf33ad72211) 一文中有提到，**每一个请求都需要添加相同的 header的时候可以使用 OkHttp 的 interceptor 来指定。**\n\n```\nnew Retrofit.Builder()\n           .addConverterFactory(GsonConverterFactory.create())\n           .client(new OkHttpClient.Builder()\n                   .addInterceptor(new Interceptor() {\n                       @Override\n                       public Response intercept(Chain chain) throws IOException {\n                           Request request = chain.request()\n                                   .newBuilder()\n                                   .addHeader(\"Accept\", \"application/vnd.github.v3.full+json\")\n                                   .addHeader(\"User-Agent\", \"Retrofit-Sample-App\")\n                                   .build();\n                           return chain.proceed(request);\n                       }\n                   })\n\n                   .build()\n```\n***\n### 3.支持自签名的https \n\n\n首先这里要说一下，看到网上说了很多okhttp如何支持https的文章。首先要了解的是，okhttp默认情况下是支持https协议的网站的，比如 *https://www.baidu.com* 等，这些网站可以直接通过okhttp请求，不需要添加而外的支持。不过要注意的是，支持的https的网站基本都是CA机构颁发的证书，默认情况下是可以信任的。\n\n然后我们今天要说的是自签名的https，什么叫自签名呢？就是自己通过keytool去生成一个证书，然后使用，并不是CA机构去颁发的。使用自签名证书的网站，大家在使用浏览器访问的时候，一般都是报风险警告，好在有个大名鼎鼎的网站就是这么干的，https://kyfw.12306.cn/otn/ ，点击进入12306的购票页面就能看到了。\n\n在写本文之前也查看了很多资料，我呢，尽量把每一步都说的详细一点。\n\n>SSL单向认证\n\n加入证书源文件，证书可以放在assets 下面，或者raw 下面也是可以的：\n\n![配图1](/imgs/2149115-a75ab976a221b88c.png)\n\n\n- 构造keyStore对象， 然后将得到的CertificateStream放入到keyStore中。\n```\nInputStream certificateStream = mContext.getResources().openRawResource(R.raw.srca);\n\n KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n\n keyStore.load(certificateStream, \"password\".toCharArray());    \n```\n- 接下来利用keyStore去初始化我们的TrustManagerFactory.\n\n```\nTrustManagerFactory trustManagerFactory = \n          TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); \ntrustManagerFactory.init(keyStore);\n```\n- 由trustManagerFactory.getTrustManagers获得TrustManager[]初 始化我们的SSLContext\n```\n//\"TLS\" SSL协议 由服务器端确定\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init ( \n                null, \n                trustManagerFactory.getTrustManagers(), \n                null);\n```\n根据okhttp3.0以前的版本，上面这样写是没问题的，3.0以后版本API文档中，这样写道:\nIf necessary, you can create and configure the defaults yourself with the following code:\n如果有必要，你可以参考下面的代码根据自己的需求创建和设置的默认值。\n\n```\nTrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(\n       TrustManagerFactory.getDefaultAlgorithm());\n trustManagerFactory.init((KeyStore) null);\n TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\nif (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {\n     throw new IllegalStateException(\"Unexpected default trust managers:\"\n         + Arrays.toString(trustManagers));\n   }\nX509TrustManager trustManager = (X509TrustManager) trustManagers[0];\n\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(null, new TrustManager[] { trustManager }, null);\nSSLSocketFactory sslSocketFactory =\n        sslContext.getSocketFactory();\n\nOkHttpClient client = new OkHttpClient.Builder()\n       .sslSocketFactory(sslSocketFactory, trustManager);\n       .build();\n```\n- 那根据上面的提供，我们来修改一下SSLContext的初始化：\n```\nTrustsManager[] trustManagers = trustManagerFactory.getTrustManagers();\nX509TrustManager trustManager = chooseTrustManager(trustManagers);\nif (trustManager != null) {   \n     trustManager = new MyTrustManager(chooseTrustManager(trustManagers));\n     } else {  \n      trustManager = new UnSafeTrustManager();\n     }\nsslContext.init(null, new TrustManager[]{trustManager}, null);\n```\n\n```\nprivate static X509TrustManager chooseTrustManager(TrustManager[] trustManagers) {\n    for (TrustManager trustManager : trustManagers) {\n        if (trustManager instanceof X509TrustManager) {\n            return (X509TrustManager) trustManager;\n        }    \n  } \n  return null;\n}\n```\n\n```\nprivate static class MyTrustManager implements X509TrustManager {\n    private X509TrustManager defaultTrustManager;\n    private X509TrustManager localTrustManager;\n    public MyTrustManager(X509TrustManager localTrustManager) throws NoSuchAlgorithmException, KeyStoreException {\n        TrustManagerFactory var4 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        var4.init((KeyStore) null);\n        this.defaultTrustManager = chooseTrustManager(var4.getTrustManagers());\n        this.localTrustManager = localTrustManager;\n    }\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n    }\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        try {\n            localTrustManager.checkServerTrusted(chain, authType);\n        } catch (CertificateException ce) {\n            defaultTrustManager.checkServerTrusted(chain, authType);\n        }\n    }\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return new X509Certificate[0];\n    }\n}\n```\n\n- 最后，设置我们OkHttpClient即可。\n\n```\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)).build();\n```\n到此为止，单向认证基本讲完了 ，接下来双向认证就相对简单了。\n\n>SSL双向认证\n\n核心代码：\n```\n//初始化keystore\nKeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());\nclientKeyStore.load(mContext.getAssets().open(\"zhy_client.bks\"), \"123456\".toCharArray());\n\nKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\nkeyManagerFactory.init(clientKeyStore, \"123456\".toCharArray());\n\nsslContext.init(keyManagerFactory.getKeyManagers(), new TrustManager[]{trustManager}, null);\n```\n关于客户端证书文件，Java平台默认识别jks格式的证书文件，但是android平台只识别bks格式的证书文件。\n\n***\n### 4.认证机构认证后的https\n>添加证书certificatePinner\ncertificatePinner(CertificatePinner certificatePinner) 的是在 由正式证书颁发机构认证的情况下，避免证书颁发机构的非法访问。\n\n```\nOkHttpClient client = new OkHttpClient.Builder()\n    .certificatePinner(new CertificatePinner.Builder()\n            .add(\"YOU API.com\", \"sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=\")\n            .add(\"YOU API..com\", \"sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=\")\n            .add(\"YOU API..com\", \"sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=\")\n            .add(\"YOU API..com\", \"sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=\")\n            .build())\n```\n\n>这是主机名验证\n设置用于确认响应证书申请请求的主机名的HTTPS连接的验证。\n如果不设置，默认的主机名校验将被使用。\n\n```\nokhttpBuilder.hostnameVerifier(HttpsFactroy.getHostnameVerifier(hosts));\n```\n\n最后，Retrofit与 okhttp3.0的结合：\n```\nretrofit = new Retrofit.Builder().client(client).build();\n```\n\n# 总结\n关于okhttp的使用，本文不多说，主要是retrofit与okhttp相结合使用中用到的部分，本文也只是本人在 okhttp 与 retrofit 的结合使用中的一点总结，如果有不对的地方，望书友们指导。\n\n***\n参考文章：\n\n- [Retrofit 2.0 超能实践，完美支持加密Https传输](http://www.jianshu.com/p/16994e49e2f6)\n- [okHttp官方文档](http://square.github.io/okhttp/3.x/okhttp/)\n- [Android Https相关完全解析 当OkHttp遇到Https](http://blog.csdn.net/lmj623565791/article/details/48129405)","source":"_posts/Retrofit2-1学习-与okhttp3-0结合使用.md","raw":"---\ntitle: Retrofit2.1学习:与okhttp3.0结合使用\ndate: 2016-10-31 09:15:36\ntags:\ncategories: Retrofit2.1\n---\n![配图](/imgs/2149115-f2becc1a2a11fcfc.jpg)\n\n### 1.添加日志输出\n\n\n```\nRetrofit retrofit = new Retrofit.Builder().client(new OkHttpClient.Builder().addNetworkInterceptor(\n   new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.HEADERS)).build());\n```\n<!-- more-->\n***\n### 2.添加请求头信息\n\n在 [Retrofit官方文档的翻译](http://www.jianshu.com/p/8cf33ad72211) 一文中有提到，**每一个请求都需要添加相同的 header的时候可以使用 OkHttp 的 interceptor 来指定。**\n\n```\nnew Retrofit.Builder()\n           .addConverterFactory(GsonConverterFactory.create())\n           .client(new OkHttpClient.Builder()\n                   .addInterceptor(new Interceptor() {\n                       @Override\n                       public Response intercept(Chain chain) throws IOException {\n                           Request request = chain.request()\n                                   .newBuilder()\n                                   .addHeader(\"Accept\", \"application/vnd.github.v3.full+json\")\n                                   .addHeader(\"User-Agent\", \"Retrofit-Sample-App\")\n                                   .build();\n                           return chain.proceed(request);\n                       }\n                   })\n\n                   .build()\n```\n***\n### 3.支持自签名的https \n\n\n首先这里要说一下，看到网上说了很多okhttp如何支持https的文章。首先要了解的是，okhttp默认情况下是支持https协议的网站的，比如 *https://www.baidu.com* 等，这些网站可以直接通过okhttp请求，不需要添加而外的支持。不过要注意的是，支持的https的网站基本都是CA机构颁发的证书，默认情况下是可以信任的。\n\n然后我们今天要说的是自签名的https，什么叫自签名呢？就是自己通过keytool去生成一个证书，然后使用，并不是CA机构去颁发的。使用自签名证书的网站，大家在使用浏览器访问的时候，一般都是报风险警告，好在有个大名鼎鼎的网站就是这么干的，https://kyfw.12306.cn/otn/ ，点击进入12306的购票页面就能看到了。\n\n在写本文之前也查看了很多资料，我呢，尽量把每一步都说的详细一点。\n\n>SSL单向认证\n\n加入证书源文件，证书可以放在assets 下面，或者raw 下面也是可以的：\n\n![配图1](/imgs/2149115-a75ab976a221b88c.png)\n\n\n- 构造keyStore对象， 然后将得到的CertificateStream放入到keyStore中。\n```\nInputStream certificateStream = mContext.getResources().openRawResource(R.raw.srca);\n\n KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n\n keyStore.load(certificateStream, \"password\".toCharArray());    \n```\n- 接下来利用keyStore去初始化我们的TrustManagerFactory.\n\n```\nTrustManagerFactory trustManagerFactory = \n          TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); \ntrustManagerFactory.init(keyStore);\n```\n- 由trustManagerFactory.getTrustManagers获得TrustManager[]初 始化我们的SSLContext\n```\n//\"TLS\" SSL协议 由服务器端确定\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init ( \n                null, \n                trustManagerFactory.getTrustManagers(), \n                null);\n```\n根据okhttp3.0以前的版本，上面这样写是没问题的，3.0以后版本API文档中，这样写道:\nIf necessary, you can create and configure the defaults yourself with the following code:\n如果有必要，你可以参考下面的代码根据自己的需求创建和设置的默认值。\n\n```\nTrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(\n       TrustManagerFactory.getDefaultAlgorithm());\n trustManagerFactory.init((KeyStore) null);\n TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\nif (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {\n     throw new IllegalStateException(\"Unexpected default trust managers:\"\n         + Arrays.toString(trustManagers));\n   }\nX509TrustManager trustManager = (X509TrustManager) trustManagers[0];\n\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(null, new TrustManager[] { trustManager }, null);\nSSLSocketFactory sslSocketFactory =\n        sslContext.getSocketFactory();\n\nOkHttpClient client = new OkHttpClient.Builder()\n       .sslSocketFactory(sslSocketFactory, trustManager);\n       .build();\n```\n- 那根据上面的提供，我们来修改一下SSLContext的初始化：\n```\nTrustsManager[] trustManagers = trustManagerFactory.getTrustManagers();\nX509TrustManager trustManager = chooseTrustManager(trustManagers);\nif (trustManager != null) {   \n     trustManager = new MyTrustManager(chooseTrustManager(trustManagers));\n     } else {  \n      trustManager = new UnSafeTrustManager();\n     }\nsslContext.init(null, new TrustManager[]{trustManager}, null);\n```\n\n```\nprivate static X509TrustManager chooseTrustManager(TrustManager[] trustManagers) {\n    for (TrustManager trustManager : trustManagers) {\n        if (trustManager instanceof X509TrustManager) {\n            return (X509TrustManager) trustManager;\n        }    \n  } \n  return null;\n}\n```\n\n```\nprivate static class MyTrustManager implements X509TrustManager {\n    private X509TrustManager defaultTrustManager;\n    private X509TrustManager localTrustManager;\n    public MyTrustManager(X509TrustManager localTrustManager) throws NoSuchAlgorithmException, KeyStoreException {\n        TrustManagerFactory var4 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        var4.init((KeyStore) null);\n        this.defaultTrustManager = chooseTrustManager(var4.getTrustManagers());\n        this.localTrustManager = localTrustManager;\n    }\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n    }\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        try {\n            localTrustManager.checkServerTrusted(chain, authType);\n        } catch (CertificateException ce) {\n            defaultTrustManager.checkServerTrusted(chain, authType);\n        }\n    }\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return new X509Certificate[0];\n    }\n}\n```\n\n- 最后，设置我们OkHttpClient即可。\n\n```\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)).build();\n```\n到此为止，单向认证基本讲完了 ，接下来双向认证就相对简单了。\n\n>SSL双向认证\n\n核心代码：\n```\n//初始化keystore\nKeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());\nclientKeyStore.load(mContext.getAssets().open(\"zhy_client.bks\"), \"123456\".toCharArray());\n\nKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\nkeyManagerFactory.init(clientKeyStore, \"123456\".toCharArray());\n\nsslContext.init(keyManagerFactory.getKeyManagers(), new TrustManager[]{trustManager}, null);\n```\n关于客户端证书文件，Java平台默认识别jks格式的证书文件，但是android平台只识别bks格式的证书文件。\n\n***\n### 4.认证机构认证后的https\n>添加证书certificatePinner\ncertificatePinner(CertificatePinner certificatePinner) 的是在 由正式证书颁发机构认证的情况下，避免证书颁发机构的非法访问。\n\n```\nOkHttpClient client = new OkHttpClient.Builder()\n    .certificatePinner(new CertificatePinner.Builder()\n            .add(\"YOU API.com\", \"sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=\")\n            .add(\"YOU API..com\", \"sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=\")\n            .add(\"YOU API..com\", \"sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=\")\n            .add(\"YOU API..com\", \"sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=\")\n            .build())\n```\n\n>这是主机名验证\n设置用于确认响应证书申请请求的主机名的HTTPS连接的验证。\n如果不设置，默认的主机名校验将被使用。\n\n```\nokhttpBuilder.hostnameVerifier(HttpsFactroy.getHostnameVerifier(hosts));\n```\n\n最后，Retrofit与 okhttp3.0的结合：\n```\nretrofit = new Retrofit.Builder().client(client).build();\n```\n\n# 总结\n关于okhttp的使用，本文不多说，主要是retrofit与okhttp相结合使用中用到的部分，本文也只是本人在 okhttp 与 retrofit 的结合使用中的一点总结，如果有不对的地方，望书友们指导。\n\n***\n参考文章：\n\n- [Retrofit 2.0 超能实践，完美支持加密Https传输](http://www.jianshu.com/p/16994e49e2f6)\n- [okHttp官方文档](http://square.github.io/okhttp/3.x/okhttp/)\n- [Android Https相关完全解析 当OkHttp遇到Https](http://blog.csdn.net/lmj623565791/article/details/48129405)","slug":"Retrofit2-1学习-与okhttp3-0结合使用","published":1,"updated":"2016-11-14T02:58:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovdur0006bqc6i7kwrwoz","content":"<p><img src=\"/imgs/2149115-f2becc1a2a11fcfc.jpg\" alt=\"配图\"></p>\n<h3 id=\"1-添加日志输出\"><a href=\"#1-添加日志输出\" class=\"headerlink\" title=\"1.添加日志输出\"></a>1.添加日志输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Retrofit retrofit = new Retrofit.Builder().client(new OkHttpClient.Builder().addNetworkInterceptor(</div><div class=\"line\">   new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.HEADERS)).build());</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"2-添加请求头信息\"><a href=\"#2-添加请求头信息\" class=\"headerlink\" title=\"2.添加请求头信息\"></a>2.添加请求头信息</h3><p>在 <a href=\"http://www.jianshu.com/p/8cf33ad72211\" target=\"_blank\" rel=\"external\">Retrofit官方文档的翻译</a> 一文中有提到，<strong>每一个请求都需要添加相同的 header的时候可以使用 OkHttp 的 interceptor 来指定。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Retrofit.Builder()</div><div class=\"line\">           .addConverterFactory(GsonConverterFactory.create())</div><div class=\"line\">           .client(new OkHttpClient.Builder()</div><div class=\"line\">                   .addInterceptor(new Interceptor() &#123;</div><div class=\"line\">                       @Override</div><div class=\"line\">                       public Response intercept(Chain chain) throws IOException &#123;</div><div class=\"line\">                           Request request = chain.request()</div><div class=\"line\">                                   .newBuilder()</div><div class=\"line\">                                   .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3.full+json&quot;)</div><div class=\"line\">                                   .addHeader(&quot;User-Agent&quot;, &quot;Retrofit-Sample-App&quot;)</div><div class=\"line\">                                   .build();</div><div class=\"line\">                           return chain.proceed(request);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;)</div><div class=\"line\"></div><div class=\"line\">                   .build()</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3-支持自签名的https\"><a href=\"#3-支持自签名的https\" class=\"headerlink\" title=\"3.支持自签名的https\"></a>3.支持自签名的https</h3><p>首先这里要说一下，看到网上说了很多okhttp如何支持https的文章。首先要了解的是，okhttp默认情况下是支持https协议的网站的，比如 <em><a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"external\">https://www.baidu.com</a></em> 等，这些网站可以直接通过okhttp请求，不需要添加而外的支持。不过要注意的是，支持的https的网站基本都是CA机构颁发的证书，默认情况下是可以信任的。</p>\n<p>然后我们今天要说的是自签名的https，什么叫自签名呢？就是自己通过keytool去生成一个证书，然后使用，并不是CA机构去颁发的。使用自签名证书的网站，大家在使用浏览器访问的时候，一般都是报风险警告，好在有个大名鼎鼎的网站就是这么干的，<a href=\"https://kyfw.12306.cn/otn/\" target=\"_blank\" rel=\"external\">https://kyfw.12306.cn/otn/</a> ，点击进入12306的购票页面就能看到了。</p>\n<p>在写本文之前也查看了很多资料，我呢，尽量把每一步都说的详细一点。</p>\n<blockquote>\n<p>SSL单向认证</p>\n</blockquote>\n<p>加入证书源文件，证书可以放在assets 下面，或者raw 下面也是可以的：</p>\n<p><img src=\"/imgs/2149115-a75ab976a221b88c.png\" alt=\"配图1\"></p>\n<ul>\n<li><p>构造keyStore对象， 然后将得到的CertificateStream放入到keyStore中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">InputStream certificateStream = mContext.getResources().openRawResource(R.raw.srca);</div><div class=\"line\"></div><div class=\"line\"> KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</div><div class=\"line\"></div><div class=\"line\"> keyStore.load(certificateStream, &quot;password&quot;.toCharArray());</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来利用keyStore去初始化我们的TrustManagerFactory.</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManagerFactory trustManagerFactory = </div><div class=\"line\">          TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); </div><div class=\"line\">trustManagerFactory.init(keyStore);</div></pre></td></tr></table></figure>\n<ul>\n<li>由trustManagerFactory.getTrustManagers获得TrustManager[]初 始化我们的SSLContext<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//&quot;TLS&quot; SSL协议 由服务器端确定</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</div><div class=\"line\">sslContext.init ( </div><div class=\"line\">                null, </div><div class=\"line\">                trustManagerFactory.getTrustManagers(), </div><div class=\"line\">                null);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>根据okhttp3.0以前的版本，上面这样写是没问题的，3.0以后版本API文档中，这样写道:<br>If necessary, you can create and configure the defaults yourself with the following code:<br>如果有必要，你可以参考下面的代码根据自己的需求创建和设置的默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(</div><div class=\"line\">       TrustManagerFactory.getDefaultAlgorithm());</div><div class=\"line\"> trustManagerFactory.init((KeyStore) null);</div><div class=\"line\"> TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</div><div class=\"line\">if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) &#123;</div><div class=\"line\">     throw new IllegalStateException(&quot;Unexpected default trust managers:&quot;</div><div class=\"line\">         + Arrays.toString(trustManagers));</div><div class=\"line\">   &#125;</div><div class=\"line\">X509TrustManager trustManager = (X509TrustManager) trustManagers[0];</div><div class=\"line\"></div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</div><div class=\"line\">sslContext.init(null, new TrustManager[] &#123; trustManager &#125;, null);</div><div class=\"line\">SSLSocketFactory sslSocketFactory =</div><div class=\"line\">        sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\">OkHttpClient client = new OkHttpClient.Builder()</div><div class=\"line\">       .sslSocketFactory(sslSocketFactory, trustManager);</div><div class=\"line\">       .build();</div></pre></td></tr></table></figure>\n<ul>\n<li>那根据上面的提供，我们来修改一下SSLContext的初始化：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustsManager[] trustManagers = trustManagerFactory.getTrustManagers();</div><div class=\"line\">X509TrustManager trustManager = chooseTrustManager(trustManagers);</div><div class=\"line\">if (trustManager != null) &#123;   </div><div class=\"line\">     trustManager = new MyTrustManager(chooseTrustManager(trustManagers));</div><div class=\"line\">     &#125; else &#123;  </div><div class=\"line\">      trustManager = new UnSafeTrustManager();</div><div class=\"line\">     &#125;</div><div class=\"line\">sslContext.init(null, new TrustManager[]&#123;trustManager&#125;, null);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static X509TrustManager chooseTrustManager(TrustManager[] trustManagers) &#123;</div><div class=\"line\">    for (TrustManager trustManager : trustManagers) &#123;</div><div class=\"line\">        if (trustManager instanceof X509TrustManager) &#123;</div><div class=\"line\">            return (X509TrustManager) trustManager;</div><div class=\"line\">        &#125;    </div><div class=\"line\">  &#125; </div><div class=\"line\">  return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static class MyTrustManager implements X509TrustManager &#123;</div><div class=\"line\">    private X509TrustManager defaultTrustManager;</div><div class=\"line\">    private X509TrustManager localTrustManager;</div><div class=\"line\">    public MyTrustManager(X509TrustManager localTrustManager) throws NoSuchAlgorithmException, KeyStoreException &#123;</div><div class=\"line\">        TrustManagerFactory var4 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</div><div class=\"line\">        var4.init((KeyStore) null);</div><div class=\"line\">        this.defaultTrustManager = chooseTrustManager(var4.getTrustManagers());</div><div class=\"line\">        this.localTrustManager = localTrustManager;</div><div class=\"line\">    &#125;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            localTrustManager.checkServerTrusted(chain, authType);</div><div class=\"line\">        &#125; catch (CertificateException ce) &#123;</div><div class=\"line\">            defaultTrustManager.checkServerTrusted(chain, authType);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    @Override</div><div class=\"line\">    public X509Certificate[] getAcceptedIssuers() &#123;</div><div class=\"line\">        return new X509Certificate[0];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>最后，设置我们OkHttpClient即可。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient okHttpClient = new OkHttpClient.Builder()</div><div class=\"line\">        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)).build();</div></pre></td></tr></table></figure>\n<p>到此为止，单向认证基本讲完了 ，接下来双向认证就相对简单了。</p>\n<blockquote>\n<p>SSL双向认证</p>\n</blockquote>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化keystore</div><div class=\"line\">KeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());</div><div class=\"line\">clientKeyStore.load(mContext.getAssets().open(&quot;zhy_client.bks&quot;), &quot;123456&quot;.toCharArray());</div><div class=\"line\"></div><div class=\"line\">KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</div><div class=\"line\">keyManagerFactory.init(clientKeyStore, &quot;123456&quot;.toCharArray());</div><div class=\"line\"></div><div class=\"line\">sslContext.init(keyManagerFactory.getKeyManagers(), new TrustManager[]&#123;trustManager&#125;, null);</div></pre></td></tr></table></figure></p>\n<p>关于客户端证书文件，Java平台默认识别jks格式的证书文件，但是android平台只识别bks格式的证书文件。</p>\n<hr>\n<h3 id=\"4-认证机构认证后的https\"><a href=\"#4-认证机构认证后的https\" class=\"headerlink\" title=\"4.认证机构认证后的https\"></a>4.认证机构认证后的https</h3><blockquote>\n<p>添加证书certificatePinner<br>certificatePinner(CertificatePinner certificatePinner) 的是在 由正式证书颁发机构认证的情况下，避免证书颁发机构的非法访问。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = new OkHttpClient.Builder()</div><div class=\"line\">    .certificatePinner(new CertificatePinner.Builder()</div><div class=\"line\">            .add(&quot;YOU API.com&quot;, &quot;sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=&quot;)</div><div class=\"line\">            .add(&quot;YOU API..com&quot;, &quot;sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=&quot;)</div><div class=\"line\">            .add(&quot;YOU API..com&quot;, &quot;sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=&quot;)</div><div class=\"line\">            .add(&quot;YOU API..com&quot;, &quot;sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=&quot;)</div><div class=\"line\">            .build())</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这是主机名验证<br>设置用于确认响应证书申请请求的主机名的HTTPS连接的验证。<br>如果不设置，默认的主机名校验将被使用。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">okhttpBuilder.hostnameVerifier(HttpsFactroy.getHostnameVerifier(hosts));</div></pre></td></tr></table></figure>\n<p>最后，Retrofit与 okhttp3.0的结合：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">retrofit = new Retrofit.Builder().client(client).build();</div></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>关于okhttp的使用，本文不多说，主要是retrofit与okhttp相结合使用中用到的部分，本文也只是本人在 okhttp 与 retrofit 的结合使用中的一点总结，如果有不对的地方，望书友们指导。</p>\n<hr>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/16994e49e2f6\" target=\"_blank\" rel=\"external\">Retrofit 2.0 超能实践，完美支持加密Https传输</a></li>\n<li><a href=\"http://square.github.io/okhttp/3.x/okhttp/\" target=\"_blank\" rel=\"external\">okHttp官方文档</a></li>\n<li><a href=\"http://blog.csdn.net/lmj623565791/article/details/48129405\" target=\"_blank\" rel=\"external\">Android Https相关完全解析 当OkHttp遇到Https</a></li>\n</ul>\n","excerpt":"<p><img src=\"/imgs/2149115-f2becc1a2a11fcfc.jpg\" alt=\"配图\"></p>\n<h3 id=\"1-添加日志输出\"><a href=\"#1-添加日志输出\" class=\"headerlink\" title=\"1.添加日志输出\"></a>1.添加日志输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Retrofit retrofit = new Retrofit.Builder().client(new OkHttpClient.Builder().addNetworkInterceptor(</div><div class=\"line\">   new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.HEADERS)).build());</div></pre></td></tr></table></figure>","more":"<hr>\n<h3 id=\"2-添加请求头信息\"><a href=\"#2-添加请求头信息\" class=\"headerlink\" title=\"2.添加请求头信息\"></a>2.添加请求头信息</h3><p>在 <a href=\"http://www.jianshu.com/p/8cf33ad72211\">Retrofit官方文档的翻译</a> 一文中有提到，<strong>每一个请求都需要添加相同的 header的时候可以使用 OkHttp 的 interceptor 来指定。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Retrofit.Builder()</div><div class=\"line\">           .addConverterFactory(GsonConverterFactory.create())</div><div class=\"line\">           .client(new OkHttpClient.Builder()</div><div class=\"line\">                   .addInterceptor(new Interceptor() &#123;</div><div class=\"line\">                       @Override</div><div class=\"line\">                       public Response intercept(Chain chain) throws IOException &#123;</div><div class=\"line\">                           Request request = chain.request()</div><div class=\"line\">                                   .newBuilder()</div><div class=\"line\">                                   .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3.full+json&quot;)</div><div class=\"line\">                                   .addHeader(&quot;User-Agent&quot;, &quot;Retrofit-Sample-App&quot;)</div><div class=\"line\">                                   .build();</div><div class=\"line\">                           return chain.proceed(request);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;)</div><div class=\"line\"></div><div class=\"line\">                   .build()</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3-支持自签名的https\"><a href=\"#3-支持自签名的https\" class=\"headerlink\" title=\"3.支持自签名的https\"></a>3.支持自签名的https</h3><p>首先这里要说一下，看到网上说了很多okhttp如何支持https的文章。首先要了解的是，okhttp默认情况下是支持https协议的网站的，比如 <em><a href=\"https://www.baidu.com\">https://www.baidu.com</a></em> 等，这些网站可以直接通过okhttp请求，不需要添加而外的支持。不过要注意的是，支持的https的网站基本都是CA机构颁发的证书，默认情况下是可以信任的。</p>\n<p>然后我们今天要说的是自签名的https，什么叫自签名呢？就是自己通过keytool去生成一个证书，然后使用，并不是CA机构去颁发的。使用自签名证书的网站，大家在使用浏览器访问的时候，一般都是报风险警告，好在有个大名鼎鼎的网站就是这么干的，<a href=\"https://kyfw.12306.cn/otn/\">https://kyfw.12306.cn/otn/</a> ，点击进入12306的购票页面就能看到了。</p>\n<p>在写本文之前也查看了很多资料，我呢，尽量把每一步都说的详细一点。</p>\n<blockquote>\n<p>SSL单向认证</p>\n</blockquote>\n<p>加入证书源文件，证书可以放在assets 下面，或者raw 下面也是可以的：</p>\n<p><img src=\"/imgs/2149115-a75ab976a221b88c.png\" alt=\"配图1\"></p>\n<ul>\n<li><p>构造keyStore对象， 然后将得到的CertificateStream放入到keyStore中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">InputStream certificateStream = mContext.getResources().openRawResource(R.raw.srca);</div><div class=\"line\"></div><div class=\"line\"> KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</div><div class=\"line\"></div><div class=\"line\"> keyStore.load(certificateStream, &quot;password&quot;.toCharArray());</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来利用keyStore去初始化我们的TrustManagerFactory.</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManagerFactory trustManagerFactory = </div><div class=\"line\">          TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); </div><div class=\"line\">trustManagerFactory.init(keyStore);</div></pre></td></tr></table></figure>\n<ul>\n<li>由trustManagerFactory.getTrustManagers获得TrustManager[]初 始化我们的SSLContext<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//&quot;TLS&quot; SSL协议 由服务器端确定</div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</div><div class=\"line\">sslContext.init ( </div><div class=\"line\">                null, </div><div class=\"line\">                trustManagerFactory.getTrustManagers(), </div><div class=\"line\">                null);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>根据okhttp3.0以前的版本，上面这样写是没问题的，3.0以后版本API文档中，这样写道:<br>If necessary, you can create and configure the defaults yourself with the following code:<br>如果有必要，你可以参考下面的代码根据自己的需求创建和设置的默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(</div><div class=\"line\">       TrustManagerFactory.getDefaultAlgorithm());</div><div class=\"line\"> trustManagerFactory.init((KeyStore) null);</div><div class=\"line\"> TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</div><div class=\"line\">if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) &#123;</div><div class=\"line\">     throw new IllegalStateException(&quot;Unexpected default trust managers:&quot;</div><div class=\"line\">         + Arrays.toString(trustManagers));</div><div class=\"line\">   &#125;</div><div class=\"line\">X509TrustManager trustManager = (X509TrustManager) trustManagers[0];</div><div class=\"line\"></div><div class=\"line\">SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</div><div class=\"line\">sslContext.init(null, new TrustManager[] &#123; trustManager &#125;, null);</div><div class=\"line\">SSLSocketFactory sslSocketFactory =</div><div class=\"line\">        sslContext.getSocketFactory();</div><div class=\"line\"></div><div class=\"line\">OkHttpClient client = new OkHttpClient.Builder()</div><div class=\"line\">       .sslSocketFactory(sslSocketFactory, trustManager);</div><div class=\"line\">       .build();</div></pre></td></tr></table></figure>\n<ul>\n<li>那根据上面的提供，我们来修改一下SSLContext的初始化：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">TrustsManager[] trustManagers = trustManagerFactory.getTrustManagers();</div><div class=\"line\">X509TrustManager trustManager = chooseTrustManager(trustManagers);</div><div class=\"line\">if (trustManager != null) &#123;   </div><div class=\"line\">     trustManager = new MyTrustManager(chooseTrustManager(trustManagers));</div><div class=\"line\">     &#125; else &#123;  </div><div class=\"line\">      trustManager = new UnSafeTrustManager();</div><div class=\"line\">     &#125;</div><div class=\"line\">sslContext.init(null, new TrustManager[]&#123;trustManager&#125;, null);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static X509TrustManager chooseTrustManager(TrustManager[] trustManagers) &#123;</div><div class=\"line\">    for (TrustManager trustManager : trustManagers) &#123;</div><div class=\"line\">        if (trustManager instanceof X509TrustManager) &#123;</div><div class=\"line\">            return (X509TrustManager) trustManager;</div><div class=\"line\">        &#125;    </div><div class=\"line\">  &#125; </div><div class=\"line\">  return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static class MyTrustManager implements X509TrustManager &#123;</div><div class=\"line\">    private X509TrustManager defaultTrustManager;</div><div class=\"line\">    private X509TrustManager localTrustManager;</div><div class=\"line\">    public MyTrustManager(X509TrustManager localTrustManager) throws NoSuchAlgorithmException, KeyStoreException &#123;</div><div class=\"line\">        TrustManagerFactory var4 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</div><div class=\"line\">        var4.init((KeyStore) null);</div><div class=\"line\">        this.defaultTrustManager = chooseTrustManager(var4.getTrustManagers());</div><div class=\"line\">        this.localTrustManager = localTrustManager;</div><div class=\"line\">    &#125;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            localTrustManager.checkServerTrusted(chain, authType);</div><div class=\"line\">        &#125; catch (CertificateException ce) &#123;</div><div class=\"line\">            defaultTrustManager.checkServerTrusted(chain, authType);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    @Override</div><div class=\"line\">    public X509Certificate[] getAcceptedIssuers() &#123;</div><div class=\"line\">        return new X509Certificate[0];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>最后，设置我们OkHttpClient即可。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient okHttpClient = new OkHttpClient.Builder()</div><div class=\"line\">        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)).build();</div></pre></td></tr></table></figure>\n<p>到此为止，单向认证基本讲完了 ，接下来双向认证就相对简单了。</p>\n<blockquote>\n<p>SSL双向认证</p>\n</blockquote>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化keystore</div><div class=\"line\">KeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());</div><div class=\"line\">clientKeyStore.load(mContext.getAssets().open(&quot;zhy_client.bks&quot;), &quot;123456&quot;.toCharArray());</div><div class=\"line\"></div><div class=\"line\">KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</div><div class=\"line\">keyManagerFactory.init(clientKeyStore, &quot;123456&quot;.toCharArray());</div><div class=\"line\"></div><div class=\"line\">sslContext.init(keyManagerFactory.getKeyManagers(), new TrustManager[]&#123;trustManager&#125;, null);</div></pre></td></tr></table></figure></p>\n<p>关于客户端证书文件，Java平台默认识别jks格式的证书文件，但是android平台只识别bks格式的证书文件。</p>\n<hr>\n<h3 id=\"4-认证机构认证后的https\"><a href=\"#4-认证机构认证后的https\" class=\"headerlink\" title=\"4.认证机构认证后的https\"></a>4.认证机构认证后的https</h3><blockquote>\n<p>添加证书certificatePinner<br>certificatePinner(CertificatePinner certificatePinner) 的是在 由正式证书颁发机构认证的情况下，避免证书颁发机构的非法访问。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = new OkHttpClient.Builder()</div><div class=\"line\">    .certificatePinner(new CertificatePinner.Builder()</div><div class=\"line\">            .add(&quot;YOU API.com&quot;, &quot;sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=&quot;)</div><div class=\"line\">            .add(&quot;YOU API..com&quot;, &quot;sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=&quot;)</div><div class=\"line\">            .add(&quot;YOU API..com&quot;, &quot;sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=&quot;)</div><div class=\"line\">            .add(&quot;YOU API..com&quot;, &quot;sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=&quot;)</div><div class=\"line\">            .build())</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这是主机名验证<br>设置用于确认响应证书申请请求的主机名的HTTPS连接的验证。<br>如果不设置，默认的主机名校验将被使用。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">okhttpBuilder.hostnameVerifier(HttpsFactroy.getHostnameVerifier(hosts));</div></pre></td></tr></table></figure>\n<p>最后，Retrofit与 okhttp3.0的结合：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">retrofit = new Retrofit.Builder().client(client).build();</div></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>关于okhttp的使用，本文不多说，主要是retrofit与okhttp相结合使用中用到的部分，本文也只是本人在 okhttp 与 retrofit 的结合使用中的一点总结，如果有不对的地方，望书友们指导。</p>\n<hr>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/16994e49e2f6\">Retrofit 2.0 超能实践，完美支持加密Https传输</a></li>\n<li><a href=\"http://square.github.io/okhttp/3.x/okhttp/\">okHttp官方文档</a></li>\n<li><a href=\"http://blog.csdn.net/lmj623565791/article/details/48129405\">Android Https相关完全解析 当OkHttp遇到Https</a></li>\n</ul>"},{"title":"Retrofit2.1官方文档的翻译","date":"2016-09-02T08:52:13.000Z","_content":"### 前言：\n\n对于Retrofit也是刚开始接触，Retrofit 的使用也并没有太多的心得，网上有很多关于Retrofit的介绍，但是在我看来先从官方文档开始学习不失是一个好的选择。\n<!-- more-->\n---\n### Retrofit\n官方文档地址：http://square.github.io/retrofit/\n>一种针对android和java的类型安全的http客户端。\n\n### Introduction\nRetrofit 将http API 装换成 一个java interface。\n```\npublic interface GitHubService {\n  @GET(\"users/{user}/repos\")\n  Call<List<Repo>> listRepos(@Path(\"user\") String user);\n}\n```\n Retrofit 类 生成一个  GitHubService interface 的实例。\n```\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.github.com/\")\n    .build();\n\nGitHubService service = retrofit.create(GitHubService.class);\n```\n每一个 Call 都要生成一个 同步或异步的http请求到远程web服务器。\n```\nCall<List<Repo>> repos = service.listRepos(\"octocat\");\n```\n\n使用注解来描述http请求（包括）：\n- 支持 替换URL参数 以及 查询参数的添加\n- 支持 将整个对象转换成 request body\n- Multipart 请求体 和 文件上传\n\n### API Declaration\n\n>通过对 interface 的方法及其参数进行注解来表示将执行一次怎样的请求。\n\n\n##### 1.REQUEST METHOD\n每一个方法都必须有一个由 请求方式 及其相对应的URL 组成的http注解。提供了5种注解方式：GET, POST, PUT, DELETE, 和 HEAD 。注解中指定对应的URL。\n```\n@GET(\"users/list\")\n```\nURL中也可以指定查询参数。\n```\n@GET(\"users/list?sort=desc\")\n```\n\n##### 2.URL MANIPULATION\n可以通过方法中的可替换参数动态修改请求的URL。可替换部分可以由大括号加上字母来表示（例如：{id}）。相应的参数则必须由 @Path 并使用相同的字母串来注释出。\n```\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId);\n```\n查询参数也可以被添加。\n```\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort);\n```\n对于复杂的查询参数 可以直接组合成一个 Map 来添加。\n```\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId, @QueryMap Map<String, String> options);\n```\n##### 3.REQUEST BODY\n可以直接指定一个对象(例子中的User)作为http 的 请求体，用@Body 来注解。\n```\n@POST(\"users/new\")\nCall<User> createUser(@Body User user);\n```\n该对象(例子中的User)将通过指定的converter(转换器)转换成 Retrofit 实例。在不添加 converter(转换器)的情况下，只有 RequestBody 可以使用。\n\n##### 4.FORM ENCODED AND MULTIPART\n方法也可以通过声明去发送 form-encoded 和 multipart 数据。方法在添加 @FormUrlEncoded 后才可以发送 Form-encoded 数据。而参数的注解要用 @Field 来完成，以 key-value的形式，包含 命名 以及 所要上传的值。\n```\n@FormUrlEncoded\n@POST(\"user/edit\")\nCall<User> updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last);\n```\n方法 在添加 @FormUrlEncoded 后可以发送 Multipart 请求。方法参数要用 @Part 注解来声明。\n```\n@Multipart\n@PUT(\"user/photo\")\nCall<User> updateUser(@Part(\"photo\") RequestBody photo, @Part(\"description\") RequestBody description);\n```\n#####5.HEADER MANIPULATION\n可以使用 @Headers  来为 方法设置静态的header。\n```\n@Headers(\"Cache-Control: max-age=640000\")\n@GET(\"widget/list\")\nCall<List<Widget>> widgetList();\n```\n```\n@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit-Sample-App\"\n})\n@GET(\"users/{username}\")\nCall<User> getUser(@Path(\"username\") String username);\n```\n**注意：header 之间不会互相覆盖。具有相同名称的所有 header 将会被包括到请求中。**\n\n一个请求的header 可以使用 @Header  来动态的修改，相应的参数必须要用@Header来提供。如果value 为 null，header会被忽略；除此之外，将对参数做toString处理后，使用处理后的结果。\n```\n@GET(\"user\")\nCall<User> getUser(@Header(\"Authorization\") String authorization)\n```\n**每一个请求都需要添加 header的时候可以使用 OkHttp 的 interceptor 来指定。**\n\n##### 6.SYNCHRONOUS VS. ASYNCHRONOUS\nCall 实例 是可以 同步或异步执行的。每个实例是只能执行一次的，但调用clone() 方法 可以重新创建一个新的可使用的实例。\n在Android系统中，回调会被执行在主线程中。而在java虚拟机中，回调会在http请求发生的线程中被执行。\n\n\n### Retrofit Configuration\nRetrofit 是 将你的API 接口都转换成可调用对象的 class。默认情况下，Retrofit设置好的平台是相当不错的，但其也允许自定义定制。\n\n##### CONVERTERS\n默认情况下，Retrofit只会反序列化 HTTP 的bodies 为 OKHTTP 的 ResponseBody类型，并且@Body 注解 也只接受 ResponseBody类型。\n\nConverters 可以被添加支持其他的类型。\n- Gson: com.squareup.retrofit2:converter-goon\n- Jackson: com.squareup.retrofit2:converter-jackson\n- Moshi: com.squareup.retrofit2:converter-mosh\n- Protobuf: com.squareup.retrofit2:converter-protobuf\n- Wire: com.squareup.retrofit2:converter-wire\n- Simple XML: com.squareup.retrofit2:converter-simplexml\n- Scalars (primitives, boxed, and String): \n- com.squareup.retrofit2:converter-scalars\n\n下面有一个例子：\n使用GsonConverterFactory类生成 GitHubService 接口的实例化，并支持Gson 反序列化数据。\n```\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.github.com\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build();\n\nGitHubService service = retrofit.create(GitHubService.class);\n```\n\n##### CUSTOM CONVERTERS\n话太长不翻译了，大体意思就是：如果你不想使用Retrofit提供的converter，可以自定义一个以实现想要的效果。当你在创建一个adapter（适配器）的时候， 创建一个class 并 extends Converter.Factory class ，给adapter传递一个该类的实例就行。\n\n\n##### GRADLE\n```\ncompile 'com.squareup.retrofit2:retrofit:2.1.0'\n```\n\n##### PROGUARD\n如果项目中添加了混淆，就把下面的文字添加到混淆文件中举行：\n\n```\n# Platform calls Class.forName on types which do not exist on Android to determine platform.\n-dontnote retrofit2.Platform\n# Platform used when running on RoboVM on iOS. Will not be used at runtime.\n-dontnote retrofit2.Platform$IOS$MainThreadExecutor\n# Platform used when running on Java 8 VMs. Will not be used at runtime.\n-dontwarn retrofit2.Platform$Java8\n# Retain generic type information for use by reflection by converters and adapters.\n-keepattributes Signature\n# Retain declared checked exceptions for use by a Proxy instance.\n-keepattributes Exceptions\n```","source":"_posts/Retrofit2-1官方文档的翻译.md","raw":"---\ntitle: Retrofit2.1官方文档的翻译\ndate: 2016-09-02 16:52:13\ntags:\ncategories: Retrofit2.1\n---\n### 前言：\n\n对于Retrofit也是刚开始接触，Retrofit 的使用也并没有太多的心得，网上有很多关于Retrofit的介绍，但是在我看来先从官方文档开始学习不失是一个好的选择。\n<!-- more-->\n---\n### Retrofit\n官方文档地址：http://square.github.io/retrofit/\n>一种针对android和java的类型安全的http客户端。\n\n### Introduction\nRetrofit 将http API 装换成 一个java interface。\n```\npublic interface GitHubService {\n  @GET(\"users/{user}/repos\")\n  Call<List<Repo>> listRepos(@Path(\"user\") String user);\n}\n```\n Retrofit 类 生成一个  GitHubService interface 的实例。\n```\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.github.com/\")\n    .build();\n\nGitHubService service = retrofit.create(GitHubService.class);\n```\n每一个 Call 都要生成一个 同步或异步的http请求到远程web服务器。\n```\nCall<List<Repo>> repos = service.listRepos(\"octocat\");\n```\n\n使用注解来描述http请求（包括）：\n- 支持 替换URL参数 以及 查询参数的添加\n- 支持 将整个对象转换成 request body\n- Multipart 请求体 和 文件上传\n\n### API Declaration\n\n>通过对 interface 的方法及其参数进行注解来表示将执行一次怎样的请求。\n\n\n##### 1.REQUEST METHOD\n每一个方法都必须有一个由 请求方式 及其相对应的URL 组成的http注解。提供了5种注解方式：GET, POST, PUT, DELETE, 和 HEAD 。注解中指定对应的URL。\n```\n@GET(\"users/list\")\n```\nURL中也可以指定查询参数。\n```\n@GET(\"users/list?sort=desc\")\n```\n\n##### 2.URL MANIPULATION\n可以通过方法中的可替换参数动态修改请求的URL。可替换部分可以由大括号加上字母来表示（例如：{id}）。相应的参数则必须由 @Path 并使用相同的字母串来注释出。\n```\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId);\n```\n查询参数也可以被添加。\n```\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort);\n```\n对于复杂的查询参数 可以直接组合成一个 Map 来添加。\n```\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId, @QueryMap Map<String, String> options);\n```\n##### 3.REQUEST BODY\n可以直接指定一个对象(例子中的User)作为http 的 请求体，用@Body 来注解。\n```\n@POST(\"users/new\")\nCall<User> createUser(@Body User user);\n```\n该对象(例子中的User)将通过指定的converter(转换器)转换成 Retrofit 实例。在不添加 converter(转换器)的情况下，只有 RequestBody 可以使用。\n\n##### 4.FORM ENCODED AND MULTIPART\n方法也可以通过声明去发送 form-encoded 和 multipart 数据。方法在添加 @FormUrlEncoded 后才可以发送 Form-encoded 数据。而参数的注解要用 @Field 来完成，以 key-value的形式，包含 命名 以及 所要上传的值。\n```\n@FormUrlEncoded\n@POST(\"user/edit\")\nCall<User> updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last);\n```\n方法 在添加 @FormUrlEncoded 后可以发送 Multipart 请求。方法参数要用 @Part 注解来声明。\n```\n@Multipart\n@PUT(\"user/photo\")\nCall<User> updateUser(@Part(\"photo\") RequestBody photo, @Part(\"description\") RequestBody description);\n```\n#####5.HEADER MANIPULATION\n可以使用 @Headers  来为 方法设置静态的header。\n```\n@Headers(\"Cache-Control: max-age=640000\")\n@GET(\"widget/list\")\nCall<List<Widget>> widgetList();\n```\n```\n@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit-Sample-App\"\n})\n@GET(\"users/{username}\")\nCall<User> getUser(@Path(\"username\") String username);\n```\n**注意：header 之间不会互相覆盖。具有相同名称的所有 header 将会被包括到请求中。**\n\n一个请求的header 可以使用 @Header  来动态的修改，相应的参数必须要用@Header来提供。如果value 为 null，header会被忽略；除此之外，将对参数做toString处理后，使用处理后的结果。\n```\n@GET(\"user\")\nCall<User> getUser(@Header(\"Authorization\") String authorization)\n```\n**每一个请求都需要添加 header的时候可以使用 OkHttp 的 interceptor 来指定。**\n\n##### 6.SYNCHRONOUS VS. ASYNCHRONOUS\nCall 实例 是可以 同步或异步执行的。每个实例是只能执行一次的，但调用clone() 方法 可以重新创建一个新的可使用的实例。\n在Android系统中，回调会被执行在主线程中。而在java虚拟机中，回调会在http请求发生的线程中被执行。\n\n\n### Retrofit Configuration\nRetrofit 是 将你的API 接口都转换成可调用对象的 class。默认情况下，Retrofit设置好的平台是相当不错的，但其也允许自定义定制。\n\n##### CONVERTERS\n默认情况下，Retrofit只会反序列化 HTTP 的bodies 为 OKHTTP 的 ResponseBody类型，并且@Body 注解 也只接受 ResponseBody类型。\n\nConverters 可以被添加支持其他的类型。\n- Gson: com.squareup.retrofit2:converter-goon\n- Jackson: com.squareup.retrofit2:converter-jackson\n- Moshi: com.squareup.retrofit2:converter-mosh\n- Protobuf: com.squareup.retrofit2:converter-protobuf\n- Wire: com.squareup.retrofit2:converter-wire\n- Simple XML: com.squareup.retrofit2:converter-simplexml\n- Scalars (primitives, boxed, and String): \n- com.squareup.retrofit2:converter-scalars\n\n下面有一个例子：\n使用GsonConverterFactory类生成 GitHubService 接口的实例化，并支持Gson 反序列化数据。\n```\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.github.com\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build();\n\nGitHubService service = retrofit.create(GitHubService.class);\n```\n\n##### CUSTOM CONVERTERS\n话太长不翻译了，大体意思就是：如果你不想使用Retrofit提供的converter，可以自定义一个以实现想要的效果。当你在创建一个adapter（适配器）的时候， 创建一个class 并 extends Converter.Factory class ，给adapter传递一个该类的实例就行。\n\n\n##### GRADLE\n```\ncompile 'com.squareup.retrofit2:retrofit:2.1.0'\n```\n\n##### PROGUARD\n如果项目中添加了混淆，就把下面的文字添加到混淆文件中举行：\n\n```\n# Platform calls Class.forName on types which do not exist on Android to determine platform.\n-dontnote retrofit2.Platform\n# Platform used when running on RoboVM on iOS. Will not be used at runtime.\n-dontnote retrofit2.Platform$IOS$MainThreadExecutor\n# Platform used when running on Java 8 VMs. Will not be used at runtime.\n-dontwarn retrofit2.Platform$Java8\n# Retain generic type information for use by reflection by converters and adapters.\n-keepattributes Signature\n# Retain declared checked exceptions for use by a Proxy instance.\n-keepattributes Exceptions\n```","slug":"Retrofit2-1官方文档的翻译","published":1,"updated":"2016-09-02T08:57:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovdus0007bqc6w6e6sgd4","content":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>对于Retrofit也是刚开始接触，Retrofit 的使用也并没有太多的心得，网上有很多关于Retrofit的介绍，但是在我看来先从官方文档开始学习不失是一个好的选择。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><h3 id=\"Retrofit\"><a href=\"#Retrofit\" class=\"headerlink\" title=\"Retrofit\"></a>Retrofit</h3><p>官方文档地址：<a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"external\">http://square.github.io/retrofit/</a></p>\n<blockquote>\n<p>一种针对android和java的类型安全的http客户端。</p>\n</blockquote>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>Retrofit 将http API 装换成 一个java interface。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface GitHubService &#123;</div><div class=\"line\">  @GET(&quot;users/&#123;user&#125;/repos&quot;)</div><div class=\"line\">  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> Retrofit 类 生成一个  GitHubService interface 的实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Retrofit retrofit = new Retrofit.Builder()</div><div class=\"line\">    .baseUrl(&quot;https://api.github.com/&quot;)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure></p>\n<p>每一个 Call 都要生成一个 同步或异步的http请求到远程web服务器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);</div></pre></td></tr></table></figure></p>\n<p>使用注解来描述http请求（包括）：</p>\n<ul>\n<li>支持 替换URL参数 以及 查询参数的添加</li>\n<li>支持 将整个对象转换成 request body</li>\n<li>Multipart 请求体 和 文件上传</li>\n</ul>\n<h3 id=\"API-Declaration\"><a href=\"#API-Declaration\" class=\"headerlink\" title=\"API Declaration\"></a>API Declaration</h3><blockquote>\n<p>通过对 interface 的方法及其参数进行注解来表示将执行一次怎样的请求。</p>\n</blockquote>\n<h5 id=\"1-REQUEST-METHOD\"><a href=\"#1-REQUEST-METHOD\" class=\"headerlink\" title=\"1.REQUEST METHOD\"></a>1.REQUEST METHOD</h5><p>每一个方法都必须有一个由 请求方式 及其相对应的URL 组成的http注解。提供了5种注解方式：GET, POST, PUT, DELETE, 和 HEAD 。注解中指定对应的URL。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;users/list&quot;)</div></pre></td></tr></table></figure></p>\n<p>URL中也可以指定查询参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;users/list?sort=desc&quot;)</div></pre></td></tr></table></figure></p>\n<h5 id=\"2-URL-MANIPULATION\"><a href=\"#2-URL-MANIPULATION\" class=\"headerlink\" title=\"2.URL MANIPULATION\"></a>2.URL MANIPULATION</h5><p>可以通过方法中的可替换参数动态修改请求的URL。可替换部分可以由大括号加上字母来表示（例如：{id}）。相应的参数则必须由 @Path 并使用相同的字母串来注释出。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;group/&#123;id&#125;/users&quot;)</div><div class=\"line\">Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId);</div></pre></td></tr></table></figure></p>\n<p>查询参数也可以被添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;group/&#123;id&#125;/users&quot;)</div><div class=\"line\">Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @Query(&quot;sort&quot;) String sort);</div></pre></td></tr></table></figure></p>\n<p>对于复杂的查询参数 可以直接组合成一个 Map 来添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;group/&#123;id&#125;/users&quot;)</div><div class=\"line\">Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @QueryMap Map&lt;String, String&gt; options);</div></pre></td></tr></table></figure></p>\n<h5 id=\"3-REQUEST-BODY\"><a href=\"#3-REQUEST-BODY\" class=\"headerlink\" title=\"3.REQUEST BODY\"></a>3.REQUEST BODY</h5><p>可以直接指定一个对象(例子中的User)作为http 的 请求体，用@Body 来注解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@POST(&quot;users/new&quot;)</div><div class=\"line\">Call&lt;User&gt; createUser(@Body User user);</div></pre></td></tr></table></figure></p>\n<p>该对象(例子中的User)将通过指定的converter(转换器)转换成 Retrofit 实例。在不添加 converter(转换器)的情况下，只有 RequestBody 可以使用。</p>\n<h5 id=\"4-FORM-ENCODED-AND-MULTIPART\"><a href=\"#4-FORM-ENCODED-AND-MULTIPART\" class=\"headerlink\" title=\"4.FORM ENCODED AND MULTIPART\"></a>4.FORM ENCODED AND MULTIPART</h5><p>方法也可以通过声明去发送 form-encoded 和 multipart 数据。方法在添加 @FormUrlEncoded 后才可以发送 Form-encoded 数据。而参数的注解要用 @Field 来完成，以 key-value的形式，包含 命名 以及 所要上传的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@FormUrlEncoded</div><div class=\"line\">@POST(&quot;user/edit&quot;)</div><div class=\"line\">Call&lt;User&gt; updateUser(@Field(&quot;first_name&quot;) String first, @Field(&quot;last_name&quot;) String last);</div></pre></td></tr></table></figure></p>\n<p>方法 在添加 @FormUrlEncoded 后可以发送 Multipart 请求。方法参数要用 @Part 注解来声明。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Multipart</div><div class=\"line\">@PUT(&quot;user/photo&quot;)</div><div class=\"line\">Call&lt;User&gt; updateUser(@Part(&quot;photo&quot;) RequestBody photo, @Part(&quot;description&quot;) RequestBody description);</div></pre></td></tr></table></figure></p>\n<p>#####5.HEADER MANIPULATION<br>可以使用 @Headers  来为 方法设置静态的header。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Headers(&quot;Cache-Control: max-age=640000&quot;)</div><div class=\"line\">@GET(&quot;widget/list&quot;)</div><div class=\"line\">Call&lt;List&lt;Widget&gt;&gt; widgetList();</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Headers(&#123;</div><div class=\"line\">    &quot;Accept: application/vnd.github.v3.full+json&quot;,</div><div class=\"line\">    &quot;User-Agent: Retrofit-Sample-App&quot;</div><div class=\"line\">&#125;)</div><div class=\"line\">@GET(&quot;users/&#123;username&#125;&quot;)</div><div class=\"line\">Call&lt;User&gt; getUser(@Path(&quot;username&quot;) String username);</div></pre></td></tr></table></figure>\n<p><strong>注意：header 之间不会互相覆盖。具有相同名称的所有 header 将会被包括到请求中。</strong></p>\n<p>一个请求的header 可以使用 @Header  来动态的修改，相应的参数必须要用@Header来提供。如果value 为 null，header会被忽略；除此之外，将对参数做toString处理后，使用处理后的结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;user&quot;)</div><div class=\"line\">Call&lt;User&gt; getUser(@Header(&quot;Authorization&quot;) String authorization)</div></pre></td></tr></table></figure></p>\n<p><strong>每一个请求都需要添加 header的时候可以使用 OkHttp 的 interceptor 来指定。</strong></p>\n<h5 id=\"6-SYNCHRONOUS-VS-ASYNCHRONOUS\"><a href=\"#6-SYNCHRONOUS-VS-ASYNCHRONOUS\" class=\"headerlink\" title=\"6.SYNCHRONOUS VS. ASYNCHRONOUS\"></a>6.SYNCHRONOUS VS. ASYNCHRONOUS</h5><p>Call 实例 是可以 同步或异步执行的。每个实例是只能执行一次的，但调用clone() 方法 可以重新创建一个新的可使用的实例。<br>在Android系统中，回调会被执行在主线程中。而在java虚拟机中，回调会在http请求发生的线程中被执行。</p>\n<h3 id=\"Retrofit-Configuration\"><a href=\"#Retrofit-Configuration\" class=\"headerlink\" title=\"Retrofit Configuration\"></a>Retrofit Configuration</h3><p>Retrofit 是 将你的API 接口都转换成可调用对象的 class。默认情况下，Retrofit设置好的平台是相当不错的，但其也允许自定义定制。</p>\n<h5 id=\"CONVERTERS\"><a href=\"#CONVERTERS\" class=\"headerlink\" title=\"CONVERTERS\"></a>CONVERTERS</h5><p>默认情况下，Retrofit只会反序列化 HTTP 的bodies 为 OKHTTP 的 ResponseBody类型，并且@Body 注解 也只接受 ResponseBody类型。</p>\n<p>Converters 可以被添加支持其他的类型。</p>\n<ul>\n<li>Gson: com.squareup.retrofit2:converter-goon</li>\n<li>Jackson: com.squareup.retrofit2:converter-jackson</li>\n<li>Moshi: com.squareup.retrofit2:converter-mosh</li>\n<li>Protobuf: com.squareup.retrofit2:converter-protobuf</li>\n<li>Wire: com.squareup.retrofit2:converter-wire</li>\n<li>Simple XML: com.squareup.retrofit2:converter-simplexml</li>\n<li>Scalars (primitives, boxed, and String): </li>\n<li>com.squareup.retrofit2:converter-scalars</li>\n</ul>\n<p>下面有一个例子：<br>使用GsonConverterFactory类生成 GitHubService 接口的实例化，并支持Gson 反序列化数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Retrofit retrofit = new Retrofit.Builder()</div><div class=\"line\">    .baseUrl(&quot;https://api.github.com&quot;)</div><div class=\"line\">    .addConverterFactory(GsonConverterFactory.create())</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure></p>\n<h5 id=\"CUSTOM-CONVERTERS\"><a href=\"#CUSTOM-CONVERTERS\" class=\"headerlink\" title=\"CUSTOM CONVERTERS\"></a>CUSTOM CONVERTERS</h5><p>话太长不翻译了，大体意思就是：如果你不想使用Retrofit提供的converter，可以自定义一个以实现想要的效果。当你在创建一个adapter（适配器）的时候， 创建一个class 并 extends Converter.Factory class ，给adapter传递一个该类的实例就行。</p>\n<h5 id=\"GRADLE\"><a href=\"#GRADLE\" class=\"headerlink\" title=\"GRADLE\"></a>GRADLE</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;</div></pre></td></tr></table></figure>\n<h5 id=\"PROGUARD\"><a href=\"#PROGUARD\" class=\"headerlink\" title=\"PROGUARD\"></a>PROGUARD</h5><p>如果项目中添加了混淆，就把下面的文字添加到混淆文件中举行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Platform calls Class.forName on types which do not exist on Android to determine platform.</div><div class=\"line\">-dontnote retrofit2.Platform</div><div class=\"line\"># Platform used when running on RoboVM on iOS. Will not be used at runtime.</div><div class=\"line\">-dontnote retrofit2.Platform$IOS$MainThreadExecutor</div><div class=\"line\"># Platform used when running on Java 8 VMs. Will not be used at runtime.</div><div class=\"line\">-dontwarn retrofit2.Platform$Java8</div><div class=\"line\"># Retain generic type information for use by reflection by converters and adapters.</div><div class=\"line\">-keepattributes Signature</div><div class=\"line\"># Retain declared checked exceptions for use by a Proxy instance.</div><div class=\"line\">-keepattributes Exceptions</div></pre></td></tr></table></figure>","excerpt":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>对于Retrofit也是刚开始接触，Retrofit 的使用也并没有太多的心得，网上有很多关于Retrofit的介绍，但是在我看来先从官方文档开始学习不失是一个好的选择。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><h3 id=\"Retrofit\"><a href=\"#Retrofit\" class=\"headerlink\" title=\"Retrofit\"></a>Retrofit</h3><p>官方文档地址：<a href=\"http://square.github.io/retrofit/\">http://square.github.io/retrofit/</a></p>\n<blockquote>\n<p>一种针对android和java的类型安全的http客户端。</p>\n</blockquote>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>Retrofit 将http API 装换成 一个java interface。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface GitHubService &#123;</div><div class=\"line\">  @GET(&quot;users/&#123;user&#125;/repos&quot;)</div><div class=\"line\">  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> Retrofit 类 生成一个  GitHubService interface 的实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Retrofit retrofit = new Retrofit.Builder()</div><div class=\"line\">    .baseUrl(&quot;https://api.github.com/&quot;)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure></p>\n<p>每一个 Call 都要生成一个 同步或异步的http请求到远程web服务器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);</div></pre></td></tr></table></figure></p>\n<p>使用注解来描述http请求（包括）：</p>\n<ul>\n<li>支持 替换URL参数 以及 查询参数的添加</li>\n<li>支持 将整个对象转换成 request body</li>\n<li>Multipart 请求体 和 文件上传</li>\n</ul>\n<h3 id=\"API-Declaration\"><a href=\"#API-Declaration\" class=\"headerlink\" title=\"API Declaration\"></a>API Declaration</h3><blockquote>\n<p>通过对 interface 的方法及其参数进行注解来表示将执行一次怎样的请求。</p>\n</blockquote>\n<h5 id=\"1-REQUEST-METHOD\"><a href=\"#1-REQUEST-METHOD\" class=\"headerlink\" title=\"1.REQUEST METHOD\"></a>1.REQUEST METHOD</h5><p>每一个方法都必须有一个由 请求方式 及其相对应的URL 组成的http注解。提供了5种注解方式：GET, POST, PUT, DELETE, 和 HEAD 。注解中指定对应的URL。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;users/list&quot;)</div></pre></td></tr></table></figure></p>\n<p>URL中也可以指定查询参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;users/list?sort=desc&quot;)</div></pre></td></tr></table></figure></p>\n<h5 id=\"2-URL-MANIPULATION\"><a href=\"#2-URL-MANIPULATION\" class=\"headerlink\" title=\"2.URL MANIPULATION\"></a>2.URL MANIPULATION</h5><p>可以通过方法中的可替换参数动态修改请求的URL。可替换部分可以由大括号加上字母来表示（例如：{id}）。相应的参数则必须由 @Path 并使用相同的字母串来注释出。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;group/&#123;id&#125;/users&quot;)</div><div class=\"line\">Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId);</div></pre></td></tr></table></figure></p>\n<p>查询参数也可以被添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;group/&#123;id&#125;/users&quot;)</div><div class=\"line\">Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @Query(&quot;sort&quot;) String sort);</div></pre></td></tr></table></figure></p>\n<p>对于复杂的查询参数 可以直接组合成一个 Map 来添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;group/&#123;id&#125;/users&quot;)</div><div class=\"line\">Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @QueryMap Map&lt;String, String&gt; options);</div></pre></td></tr></table></figure></p>\n<h5 id=\"3-REQUEST-BODY\"><a href=\"#3-REQUEST-BODY\" class=\"headerlink\" title=\"3.REQUEST BODY\"></a>3.REQUEST BODY</h5><p>可以直接指定一个对象(例子中的User)作为http 的 请求体，用@Body 来注解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@POST(&quot;users/new&quot;)</div><div class=\"line\">Call&lt;User&gt; createUser(@Body User user);</div></pre></td></tr></table></figure></p>\n<p>该对象(例子中的User)将通过指定的converter(转换器)转换成 Retrofit 实例。在不添加 converter(转换器)的情况下，只有 RequestBody 可以使用。</p>\n<h5 id=\"4-FORM-ENCODED-AND-MULTIPART\"><a href=\"#4-FORM-ENCODED-AND-MULTIPART\" class=\"headerlink\" title=\"4.FORM ENCODED AND MULTIPART\"></a>4.FORM ENCODED AND MULTIPART</h5><p>方法也可以通过声明去发送 form-encoded 和 multipart 数据。方法在添加 @FormUrlEncoded 后才可以发送 Form-encoded 数据。而参数的注解要用 @Field 来完成，以 key-value的形式，包含 命名 以及 所要上传的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@FormUrlEncoded</div><div class=\"line\">@POST(&quot;user/edit&quot;)</div><div class=\"line\">Call&lt;User&gt; updateUser(@Field(&quot;first_name&quot;) String first, @Field(&quot;last_name&quot;) String last);</div></pre></td></tr></table></figure></p>\n<p>方法 在添加 @FormUrlEncoded 后可以发送 Multipart 请求。方法参数要用 @Part 注解来声明。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Multipart</div><div class=\"line\">@PUT(&quot;user/photo&quot;)</div><div class=\"line\">Call&lt;User&gt; updateUser(@Part(&quot;photo&quot;) RequestBody photo, @Part(&quot;description&quot;) RequestBody description);</div></pre></td></tr></table></figure></p>\n<p>#####5.HEADER MANIPULATION<br>可以使用 @Headers  来为 方法设置静态的header。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Headers(&quot;Cache-Control: max-age=640000&quot;)</div><div class=\"line\">@GET(&quot;widget/list&quot;)</div><div class=\"line\">Call&lt;List&lt;Widget&gt;&gt; widgetList();</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Headers(&#123;</div><div class=\"line\">    &quot;Accept: application/vnd.github.v3.full+json&quot;,</div><div class=\"line\">    &quot;User-Agent: Retrofit-Sample-App&quot;</div><div class=\"line\">&#125;)</div><div class=\"line\">@GET(&quot;users/&#123;username&#125;&quot;)</div><div class=\"line\">Call&lt;User&gt; getUser(@Path(&quot;username&quot;) String username);</div></pre></td></tr></table></figure>\n<p><strong>注意：header 之间不会互相覆盖。具有相同名称的所有 header 将会被包括到请求中。</strong></p>\n<p>一个请求的header 可以使用 @Header  来动态的修改，相应的参数必须要用@Header来提供。如果value 为 null，header会被忽略；除此之外，将对参数做toString处理后，使用处理后的结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@GET(&quot;user&quot;)</div><div class=\"line\">Call&lt;User&gt; getUser(@Header(&quot;Authorization&quot;) String authorization)</div></pre></td></tr></table></figure></p>\n<p><strong>每一个请求都需要添加 header的时候可以使用 OkHttp 的 interceptor 来指定。</strong></p>\n<h5 id=\"6-SYNCHRONOUS-VS-ASYNCHRONOUS\"><a href=\"#6-SYNCHRONOUS-VS-ASYNCHRONOUS\" class=\"headerlink\" title=\"6.SYNCHRONOUS VS. ASYNCHRONOUS\"></a>6.SYNCHRONOUS VS. ASYNCHRONOUS</h5><p>Call 实例 是可以 同步或异步执行的。每个实例是只能执行一次的，但调用clone() 方法 可以重新创建一个新的可使用的实例。<br>在Android系统中，回调会被执行在主线程中。而在java虚拟机中，回调会在http请求发生的线程中被执行。</p>\n<h3 id=\"Retrofit-Configuration\"><a href=\"#Retrofit-Configuration\" class=\"headerlink\" title=\"Retrofit Configuration\"></a>Retrofit Configuration</h3><p>Retrofit 是 将你的API 接口都转换成可调用对象的 class。默认情况下，Retrofit设置好的平台是相当不错的，但其也允许自定义定制。</p>\n<h5 id=\"CONVERTERS\"><a href=\"#CONVERTERS\" class=\"headerlink\" title=\"CONVERTERS\"></a>CONVERTERS</h5><p>默认情况下，Retrofit只会反序列化 HTTP 的bodies 为 OKHTTP 的 ResponseBody类型，并且@Body 注解 也只接受 ResponseBody类型。</p>\n<p>Converters 可以被添加支持其他的类型。</p>\n<ul>\n<li>Gson: com.squareup.retrofit2:converter-goon</li>\n<li>Jackson: com.squareup.retrofit2:converter-jackson</li>\n<li>Moshi: com.squareup.retrofit2:converter-mosh</li>\n<li>Protobuf: com.squareup.retrofit2:converter-protobuf</li>\n<li>Wire: com.squareup.retrofit2:converter-wire</li>\n<li>Simple XML: com.squareup.retrofit2:converter-simplexml</li>\n<li>Scalars (primitives, boxed, and String): </li>\n<li>com.squareup.retrofit2:converter-scalars</li>\n</ul>\n<p>下面有一个例子：<br>使用GsonConverterFactory类生成 GitHubService 接口的实例化，并支持Gson 反序列化数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Retrofit retrofit = new Retrofit.Builder()</div><div class=\"line\">    .baseUrl(&quot;https://api.github.com&quot;)</div><div class=\"line\">    .addConverterFactory(GsonConverterFactory.create())</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure></p>\n<h5 id=\"CUSTOM-CONVERTERS\"><a href=\"#CUSTOM-CONVERTERS\" class=\"headerlink\" title=\"CUSTOM CONVERTERS\"></a>CUSTOM CONVERTERS</h5><p>话太长不翻译了，大体意思就是：如果你不想使用Retrofit提供的converter，可以自定义一个以实现想要的效果。当你在创建一个adapter（适配器）的时候， 创建一个class 并 extends Converter.Factory class ，给adapter传递一个该类的实例就行。</p>\n<h5 id=\"GRADLE\"><a href=\"#GRADLE\" class=\"headerlink\" title=\"GRADLE\"></a>GRADLE</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;</div></pre></td></tr></table></figure>\n<h5 id=\"PROGUARD\"><a href=\"#PROGUARD\" class=\"headerlink\" title=\"PROGUARD\"></a>PROGUARD</h5><p>如果项目中添加了混淆，就把下面的文字添加到混淆文件中举行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Platform calls Class.forName on types which do not exist on Android to determine platform.</div><div class=\"line\">-dontnote retrofit2.Platform</div><div class=\"line\"># Platform used when running on RoboVM on iOS. Will not be used at runtime.</div><div class=\"line\">-dontnote retrofit2.Platform$IOS$MainThreadExecutor</div><div class=\"line\"># Platform used when running on Java 8 VMs. Will not be used at runtime.</div><div class=\"line\">-dontwarn retrofit2.Platform$Java8</div><div class=\"line\"># Retain generic type information for use by reflection by converters and adapters.</div><div class=\"line\">-keepattributes Signature</div><div class=\"line\"># Retain declared checked exceptions for use by a Proxy instance.</div><div class=\"line\">-keepattributes Exceptions</div></pre></td></tr></table></figure>"},{"title":"Rxjava学习：Rxjava的进阶","date":"2016-09-05T07:56:47.000Z","_content":"### 前言\n最近有点乱，项目忙着上线，临近这个时候，项目总会出现各种问题，测试出各种bug，有的没得一大堆，尤其是出现memory leak问题，关于memory leak一直想写篇博客谈谈我的想法，这里不多说，咱来接着聊一聊Rxjava的学习。\n<!-- more-->\n\n![Rxjava学习：Rxjava的进阶](/imgs/4c1c8e5bfd6663f788acb9a9665f3ffc.jpg)\n\n### 线程控制 —— Scheduler\n线程的控制也是Rxjava种很重要的一块，Rxjava在设计上，针对数据操作的性质作了考虑，由于不同的操作所需要的线程要求不同，这样就需要 Scheduler（调度器）。\n\n默认情况下的Rxjava是不会对线程进行变换的，也就是说，事件发生在哪个线程，最终就会运行在哪个线程。\n\n先来看看Scheduler类 API中提供的线程选择：\n- Schedulers.immediate(): 默认的 Scheduler，在当前线程立即开始执行任务。\n\n- Schedulers.newThread(): 为每个任务创建一个新线程。\n\n- Schedulers.io(): 。用于IO密集型任务，如对文件的读写、数据库的操作、网络的访问等，这个调度器的线程池会根据需要增长；对于普通的计算任务，使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器。\n\n- Schedulers.computation(): 计算所使用的 Scheduler。如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量。\n\n- 另外， 对于Android 还提供一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。\n\n对于android来说，有了以上几个基本够用了，Rxjava提供了subscribeOn() 和 observeOn() 这两个方法来对线程进行控制。\n- subscribeOn() ：用来指定subscribe()方法发生的线程，通常 只需调用一次,位置则随意。\n- observeOn()：用来指定其接下来的方法的回调发生的线程。\n举个例子解释一下：\n```\nObservable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定\n    .subscribeOn(Schedulers.io())\n    .observeOn(Schedulers.newThread())\n    .map(mapOperator) // 新线程，由 observeOn() 指定\n    .observeOn(Schedulers.io())\n    .map(mapOperator2) // IO 线程，由 observeOn() 指定\n    .observeOn(AndroidSchedulers.mainThread) \n    .subscribe(subscriber);  // Android 主线程，由 observeOn() 指定\n```\n由 subscribeOn(Schedulers.io()) 指定 subscribe() 最终将发生在 io线程中，而observeOn(AndroidSchedulers.mainThread) 则表示 subscriber 的方法将发生在 主线程 中。 在来看一下，observeOn(Schedulers.newThread()) 在表示下面的方法 map(mapOperator) 中，mapOperator任务将 发生在一个新线程中，mapOperator2 发生在io线程中。\n","source":"_posts/Rxjava学习：Rxjava的进阶.md","raw":"---\ntitle: Rxjava学习：Rxjava的进阶\ndate: 2016-09-05 15:56:47\ntags: Rxjava\ncategories: Rxjava学习\n---\n### 前言\n最近有点乱，项目忙着上线，临近这个时候，项目总会出现各种问题，测试出各种bug，有的没得一大堆，尤其是出现memory leak问题，关于memory leak一直想写篇博客谈谈我的想法，这里不多说，咱来接着聊一聊Rxjava的学习。\n<!-- more-->\n\n![Rxjava学习：Rxjava的进阶](/imgs/4c1c8e5bfd6663f788acb9a9665f3ffc.jpg)\n\n### 线程控制 —— Scheduler\n线程的控制也是Rxjava种很重要的一块，Rxjava在设计上，针对数据操作的性质作了考虑，由于不同的操作所需要的线程要求不同，这样就需要 Scheduler（调度器）。\n\n默认情况下的Rxjava是不会对线程进行变换的，也就是说，事件发生在哪个线程，最终就会运行在哪个线程。\n\n先来看看Scheduler类 API中提供的线程选择：\n- Schedulers.immediate(): 默认的 Scheduler，在当前线程立即开始执行任务。\n\n- Schedulers.newThread(): 为每个任务创建一个新线程。\n\n- Schedulers.io(): 。用于IO密集型任务，如对文件的读写、数据库的操作、网络的访问等，这个调度器的线程池会根据需要增长；对于普通的计算任务，使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器。\n\n- Schedulers.computation(): 计算所使用的 Scheduler。如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量。\n\n- 另外， 对于Android 还提供一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。\n\n对于android来说，有了以上几个基本够用了，Rxjava提供了subscribeOn() 和 observeOn() 这两个方法来对线程进行控制。\n- subscribeOn() ：用来指定subscribe()方法发生的线程，通常 只需调用一次,位置则随意。\n- observeOn()：用来指定其接下来的方法的回调发生的线程。\n举个例子解释一下：\n```\nObservable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定\n    .subscribeOn(Schedulers.io())\n    .observeOn(Schedulers.newThread())\n    .map(mapOperator) // 新线程，由 observeOn() 指定\n    .observeOn(Schedulers.io())\n    .map(mapOperator2) // IO 线程，由 observeOn() 指定\n    .observeOn(AndroidSchedulers.mainThread) \n    .subscribe(subscriber);  // Android 主线程，由 observeOn() 指定\n```\n由 subscribeOn(Schedulers.io()) 指定 subscribe() 最终将发生在 io线程中，而observeOn(AndroidSchedulers.mainThread) 则表示 subscriber 的方法将发生在 主线程 中。 在来看一下，observeOn(Schedulers.newThread()) 在表示下面的方法 map(mapOperator) 中，mapOperator任务将 发生在一个新线程中，mapOperator2 发生在io线程中。\n","slug":"Rxjava学习：Rxjava的进阶","published":1,"updated":"2016-09-05T08:03:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovduu0009bqc66w58onsy","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近有点乱，项目忙着上线，临近这个时候，项目总会出现各种问题，测试出各种bug，有的没得一大堆，尤其是出现memory leak问题，关于memory leak一直想写篇博客谈谈我的想法，这里不多说，咱来接着聊一聊Rxjava的学习。<br><a id=\"more\"></a></p>\n<p><img src=\"/imgs/4c1c8e5bfd6663f788acb9a9665f3ffc.jpg\" alt=\"Rxjava学习：Rxjava的进阶\"></p>\n<h3 id=\"线程控制-——-Scheduler\"><a href=\"#线程控制-——-Scheduler\" class=\"headerlink\" title=\"线程控制 —— Scheduler\"></a>线程控制 —— Scheduler</h3><p>线程的控制也是Rxjava种很重要的一块，Rxjava在设计上，针对数据操作的性质作了考虑，由于不同的操作所需要的线程要求不同，这样就需要 Scheduler（调度器）。</p>\n<p>默认情况下的Rxjava是不会对线程进行变换的，也就是说，事件发生在哪个线程，最终就会运行在哪个线程。</p>\n<p>先来看看Scheduler类 API中提供的线程选择：</p>\n<ul>\n<li><p>Schedulers.immediate(): 默认的 Scheduler，在当前线程立即开始执行任务。</p>\n</li>\n<li><p>Schedulers.newThread(): 为每个任务创建一个新线程。</p>\n</li>\n<li><p>Schedulers.io(): 。用于IO密集型任务，如对文件的读写、数据库的操作、网络的访问等，这个调度器的线程池会根据需要增长；对于普通的计算任务，使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器。</p>\n</li>\n<li><p>Schedulers.computation(): 计算所使用的 Scheduler。如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量。</p>\n</li>\n<li><p>另外， 对于Android 还提供一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</p>\n</li>\n</ul>\n<p>对于android来说，有了以上几个基本够用了，Rxjava提供了subscribeOn() 和 observeOn() 这两个方法来对线程进行控制。</p>\n<ul>\n<li>subscribeOn() ：用来指定subscribe()方法发生的线程，通常 只需调用一次,位置则随意。</li>\n<li>observeOn()：用来指定其接下来的方法的回调发生的线程。<br>举个例子解释一下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定</div><div class=\"line\">    .subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(Schedulers.newThread())</div><div class=\"line\">    .map(mapOperator) // 新线程，由 observeOn() 指定</div><div class=\"line\">    .observeOn(Schedulers.io())</div><div class=\"line\">    .map(mapOperator2) // IO 线程，由 observeOn() 指定</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread) </div><div class=\"line\">    .subscribe(subscriber);  // Android 主线程，由 observeOn() 指定</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>由 subscribeOn(Schedulers.io()) 指定 subscribe() 最终将发生在 io线程中，而observeOn(AndroidSchedulers.mainThread) 则表示 subscriber 的方法将发生在 主线程 中。 在来看一下，observeOn(Schedulers.newThread()) 在表示下面的方法 map(mapOperator) 中，mapOperator任务将 发生在一个新线程中，mapOperator2 发生在io线程中。</p>\n","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近有点乱，项目忙着上线，临近这个时候，项目总会出现各种问题，测试出各种bug，有的没得一大堆，尤其是出现memory leak问题，关于memory leak一直想写篇博客谈谈我的想法，这里不多说，咱来接着聊一聊Rxjava的学习。<br>","more":"</p>\n<p><img src=\"/imgs/4c1c8e5bfd6663f788acb9a9665f3ffc.jpg\" alt=\"Rxjava学习：Rxjava的进阶\"></p>\n<h3 id=\"线程控制-——-Scheduler\"><a href=\"#线程控制-——-Scheduler\" class=\"headerlink\" title=\"线程控制 —— Scheduler\"></a>线程控制 —— Scheduler</h3><p>线程的控制也是Rxjava种很重要的一块，Rxjava在设计上，针对数据操作的性质作了考虑，由于不同的操作所需要的线程要求不同，这样就需要 Scheduler（调度器）。</p>\n<p>默认情况下的Rxjava是不会对线程进行变换的，也就是说，事件发生在哪个线程，最终就会运行在哪个线程。</p>\n<p>先来看看Scheduler类 API中提供的线程选择：</p>\n<ul>\n<li><p>Schedulers.immediate(): 默认的 Scheduler，在当前线程立即开始执行任务。</p>\n</li>\n<li><p>Schedulers.newThread(): 为每个任务创建一个新线程。</p>\n</li>\n<li><p>Schedulers.io(): 。用于IO密集型任务，如对文件的读写、数据库的操作、网络的访问等，这个调度器的线程池会根据需要增长；对于普通的计算任务，使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器。</p>\n</li>\n<li><p>Schedulers.computation(): 计算所使用的 Scheduler。如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量。</p>\n</li>\n<li><p>另外， 对于Android 还提供一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</p>\n</li>\n</ul>\n<p>对于android来说，有了以上几个基本够用了，Rxjava提供了subscribeOn() 和 observeOn() 这两个方法来对线程进行控制。</p>\n<ul>\n<li>subscribeOn() ：用来指定subscribe()方法发生的线程，通常 只需调用一次,位置则随意。</li>\n<li>observeOn()：用来指定其接下来的方法的回调发生的线程。<br>举个例子解释一下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定</div><div class=\"line\">    .subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(Schedulers.newThread())</div><div class=\"line\">    .map(mapOperator) // 新线程，由 observeOn() 指定</div><div class=\"line\">    .observeOn(Schedulers.io())</div><div class=\"line\">    .map(mapOperator2) // IO 线程，由 observeOn() 指定</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread) </div><div class=\"line\">    .subscribe(subscriber);  // Android 主线程，由 observeOn() 指定</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>由 subscribeOn(Schedulers.io()) 指定 subscribe() 最终将发生在 io线程中，而observeOn(AndroidSchedulers.mainThread) 则表示 subscriber 的方法将发生在 主线程 中。 在来看一下，observeOn(Schedulers.newThread()) 在表示下面的方法 map(mapOperator) 中，mapOperator任务将 发生在一个新线程中，mapOperator2 发生在io线程中。</p>"},{"title":"从EventBus2.0 到 EventBus3.0","date":"2016-08-28T06:37:35.000Z","_content":"![配图](/imgs/EventBus-Top.jpg)\n\n\n### 前言：\n以前开发一直在用 EventBus2.0，最近想学点新东西，看到EventBus竟然出3.0了，看时间是早就有了，但一直没接触过，就学习学习，也顺便谈谈我在使用两个版本时，对它们的不同的感受。\n开讲之前先付一下源码地址：https://github.com/greenrobot/EventBus\n<!-- more-->\n### 介绍一下：\nEventBus是由大名鼎鼎的greenrobot出品的一个用于Android中事件发布/订阅的库。简单点说就是用于Fragment，Activity，Service，线程之间进行数据传递，它为开发者提供除了 intent、handler、boardcast这几种传递数据的方式之外的一种选择，其优点在于 几乎不怎么消化资源，并且代码优雅简洁。\n\n### EventBus 的组成\n\n![EventBus-Publish-Subscribe](/imgs/EventBus-Publish-Subscribe.png)\n\n从上图我们可以看到，EventBus 作为事件总线，有3个重要做成部分：\n- Publisher: 发布者。 表示数据的持有者，通过eventbus.post(obj)方法将数据传递出去，然而并不关心数据是否被接受，以及数据的传递过程。获取方法也很简单：\n```\nEventBus.getDefault();\n``` \n- Event:事件。这里我习惯称之为数据，就是你所要传递出得对象。\n- Subscriber: 订阅者。 或者好理解点的话，可是称之为接收者，数据将通过这些函数来进行接受。EventBus这里提供了四个函数且只能用这四个：**onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync .**当然，上面的方法是对于EventBus2.0中用到的 下面会重点讲一下3.0的用法。\n\n### EventBus 四个Subscriber\n\n首先在将四种方式之前不得不说一下ThreadMode, ThreadMode 是EventBus中一个很重要的概念，其本身是一个enum，他同样提供了四个默认属性值：Async，BackgroundThread，MainThread，PostThread；而在3.0中则改为\nASYNC，BACKGROUND，MAIN，POSTING。分别对应四个方法。\n\n先来说一下2.0中的Subscriber\n>**onEvent**\n对应 PostThread，当使用onEvent作为订阅函数时，发布者在哪个线程发布事件，onEvent就会在**哪个线程**接收事件。因为函数执行的线程不确定，这就要求用户 最好不要执行耗时操作，可能会出现线程阻塞或者事件分发不及时的问题。\n注意一点：**方法的修饰符 最好 使用 public **\n\n```\npublic void onEvent（Object obj）{\n  \n}\n```\n>** onEventMainThread**\n对应 MainThread，当使用onEventMainThread作为订阅函数时，发布者不管在哪个线程发布事件，onEventMainThread都会在**主线程**接收事件。这就要求用户 一定不要执行耗时操作，不然会造成线程阻塞。\n\n```\npublic void onEventMainThread（Object obj）{\n  \n}\n```\n\n>** onEventBackground**\n对应 BackgroundThread，当使用onEventBackground作为订阅函数时，发布者如果在主线程发布事件，onEventBackground将会**新开一个子线程**并接收事件，但是如果是在子线程中发布事件，onEventBackground将会直接在**该子线程**中接受事件。\n\n```\npublic void onEventBackground（Object obj）{\n  \n}\n```\n\n>** onEventAsync**\n对应 Async，当使用onEventAsync作为订阅函数时，发布者无论在哪个线程发布事件，onEventAsync都会**新开一个子线程**并接收事件。\n\n```\npublic void onEventAsync（Object obj）{\n  \n}\n```\n\n**而相对来说，3.0 改变对需要固定函数名的设定，提供了一种新的形式，改用注解@Subscribe ，在使用中更加灵活，而且 这里 ThreadMode 将被直接使用。**\n> onEvent 函数的实现\n\n```\n//发布线程中，调用\n@Subscribe(threadMode = ThreadMode.POSTING)\npublic void eventbusPosting(Object object){\n}\n```\n> onEventMainThread 函数的实现\n\n```\n//主线程中，调用\n@Subscribe(threadMode = ThreadMode.MAIN)\npublic void eventbusMain(Object object){\n}\n```\n> onEventBackground 函数的实现\n\n```\n//发布线程为主线程，新开子线程，调用\n//发布线程为子线程，该线程调用\n@Subscribe(threadMode = ThreadMode.BACKGROUND)\npublic void eventbusBackground(Object object){\n}\n```\n> onEventAsync 函数的实现\n\n```\n//新开子线程调用\n@Subscribe(threadMode = ThreadMode.ASYNC)\npublic void eventbusAsync(Object object){\n}\n```\n**最后说一点：EventBus 并没有摒弃固定函数名的形式，开发者仍旧可以使用这种形式，不过在使用过程中必须要 添加注解 @ Subscribe 但不用指定ThreadMode**\n\n### EventBus的基本使用\n\n#### 引入\n```\ncompile 'org.greenrobot:eventbus:3.0.0'\n```\n#### 定义事件\n```\npublic class MessageEvent { /* Additional fields if needed */ }\n```\n#### 注册订阅者\n```\nEventBus.getDefault().register(this);\n```\n#### 发送事件\n```\nEventBus.getDefault().post(messageEvent);\n```\n#### 接收事件\n```\n//eventbus2.0形式\npublic void onEvent(MessageEvent event){\n\n}\n或者\n//eventbus3.0形式\n@Subscribe(threadMode = ThreadMode.POSTING)\npublic void postingME(MessageEvent event){\n\n}\n```\n#### 注销订阅\n```\nEventBus.getDefault().unregister(this);\n```\n","source":"_posts/从EventBus2-0-到-EventBus3-0.md","raw":"---\ntitle: 从EventBus2.0 到 EventBus3.0\ndate: 2016-08-28 14:37:35\ntags: [EventBus2.0,EventBus3.0]\ncategories: EventBus\n---\n![配图](/imgs/EventBus-Top.jpg)\n\n\n### 前言：\n以前开发一直在用 EventBus2.0，最近想学点新东西，看到EventBus竟然出3.0了，看时间是早就有了，但一直没接触过，就学习学习，也顺便谈谈我在使用两个版本时，对它们的不同的感受。\n开讲之前先付一下源码地址：https://github.com/greenrobot/EventBus\n<!-- more-->\n### 介绍一下：\nEventBus是由大名鼎鼎的greenrobot出品的一个用于Android中事件发布/订阅的库。简单点说就是用于Fragment，Activity，Service，线程之间进行数据传递，它为开发者提供除了 intent、handler、boardcast这几种传递数据的方式之外的一种选择，其优点在于 几乎不怎么消化资源，并且代码优雅简洁。\n\n### EventBus 的组成\n\n![EventBus-Publish-Subscribe](/imgs/EventBus-Publish-Subscribe.png)\n\n从上图我们可以看到，EventBus 作为事件总线，有3个重要做成部分：\n- Publisher: 发布者。 表示数据的持有者，通过eventbus.post(obj)方法将数据传递出去，然而并不关心数据是否被接受，以及数据的传递过程。获取方法也很简单：\n```\nEventBus.getDefault();\n``` \n- Event:事件。这里我习惯称之为数据，就是你所要传递出得对象。\n- Subscriber: 订阅者。 或者好理解点的话，可是称之为接收者，数据将通过这些函数来进行接受。EventBus这里提供了四个函数且只能用这四个：**onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync .**当然，上面的方法是对于EventBus2.0中用到的 下面会重点讲一下3.0的用法。\n\n### EventBus 四个Subscriber\n\n首先在将四种方式之前不得不说一下ThreadMode, ThreadMode 是EventBus中一个很重要的概念，其本身是一个enum，他同样提供了四个默认属性值：Async，BackgroundThread，MainThread，PostThread；而在3.0中则改为\nASYNC，BACKGROUND，MAIN，POSTING。分别对应四个方法。\n\n先来说一下2.0中的Subscriber\n>**onEvent**\n对应 PostThread，当使用onEvent作为订阅函数时，发布者在哪个线程发布事件，onEvent就会在**哪个线程**接收事件。因为函数执行的线程不确定，这就要求用户 最好不要执行耗时操作，可能会出现线程阻塞或者事件分发不及时的问题。\n注意一点：**方法的修饰符 最好 使用 public **\n\n```\npublic void onEvent（Object obj）{\n  \n}\n```\n>** onEventMainThread**\n对应 MainThread，当使用onEventMainThread作为订阅函数时，发布者不管在哪个线程发布事件，onEventMainThread都会在**主线程**接收事件。这就要求用户 一定不要执行耗时操作，不然会造成线程阻塞。\n\n```\npublic void onEventMainThread（Object obj）{\n  \n}\n```\n\n>** onEventBackground**\n对应 BackgroundThread，当使用onEventBackground作为订阅函数时，发布者如果在主线程发布事件，onEventBackground将会**新开一个子线程**并接收事件，但是如果是在子线程中发布事件，onEventBackground将会直接在**该子线程**中接受事件。\n\n```\npublic void onEventBackground（Object obj）{\n  \n}\n```\n\n>** onEventAsync**\n对应 Async，当使用onEventAsync作为订阅函数时，发布者无论在哪个线程发布事件，onEventAsync都会**新开一个子线程**并接收事件。\n\n```\npublic void onEventAsync（Object obj）{\n  \n}\n```\n\n**而相对来说，3.0 改变对需要固定函数名的设定，提供了一种新的形式，改用注解@Subscribe ，在使用中更加灵活，而且 这里 ThreadMode 将被直接使用。**\n> onEvent 函数的实现\n\n```\n//发布线程中，调用\n@Subscribe(threadMode = ThreadMode.POSTING)\npublic void eventbusPosting(Object object){\n}\n```\n> onEventMainThread 函数的实现\n\n```\n//主线程中，调用\n@Subscribe(threadMode = ThreadMode.MAIN)\npublic void eventbusMain(Object object){\n}\n```\n> onEventBackground 函数的实现\n\n```\n//发布线程为主线程，新开子线程，调用\n//发布线程为子线程，该线程调用\n@Subscribe(threadMode = ThreadMode.BACKGROUND)\npublic void eventbusBackground(Object object){\n}\n```\n> onEventAsync 函数的实现\n\n```\n//新开子线程调用\n@Subscribe(threadMode = ThreadMode.ASYNC)\npublic void eventbusAsync(Object object){\n}\n```\n**最后说一点：EventBus 并没有摒弃固定函数名的形式，开发者仍旧可以使用这种形式，不过在使用过程中必须要 添加注解 @ Subscribe 但不用指定ThreadMode**\n\n### EventBus的基本使用\n\n#### 引入\n```\ncompile 'org.greenrobot:eventbus:3.0.0'\n```\n#### 定义事件\n```\npublic class MessageEvent { /* Additional fields if needed */ }\n```\n#### 注册订阅者\n```\nEventBus.getDefault().register(this);\n```\n#### 发送事件\n```\nEventBus.getDefault().post(messageEvent);\n```\n#### 接收事件\n```\n//eventbus2.0形式\npublic void onEvent(MessageEvent event){\n\n}\n或者\n//eventbus3.0形式\n@Subscribe(threadMode = ThreadMode.POSTING)\npublic void postingME(MessageEvent event){\n\n}\n```\n#### 注销订阅\n```\nEventBus.getDefault().unregister(this);\n```\n","slug":"从EventBus2-0-到-EventBus3-0","published":1,"updated":"2016-11-25T08:23:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovduv000bbqc697m4te1r","content":"<p><img src=\"/imgs/EventBus-Top.jpg\" alt=\"配图\"></p>\n<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>以前开发一直在用 EventBus2.0，最近想学点新东西，看到EventBus竟然出3.0了，看时间是早就有了，但一直没接触过，就学习学习，也顺便谈谈我在使用两个版本时，对它们的不同的感受。<br>开讲之前先付一下源码地址：<a href=\"https://github.com/greenrobot/EventBus\" target=\"_blank\" rel=\"external\">https://github.com/greenrobot/EventBus</a><br><a id=\"more\"></a></p>\n<h3 id=\"介绍一下：\"><a href=\"#介绍一下：\" class=\"headerlink\" title=\"介绍一下：\"></a>介绍一下：</h3><p>EventBus是由大名鼎鼎的greenrobot出品的一个用于Android中事件发布/订阅的库。简单点说就是用于Fragment，Activity，Service，线程之间进行数据传递，它为开发者提供除了 intent、handler、boardcast这几种传递数据的方式之外的一种选择，其优点在于 几乎不怎么消化资源，并且代码优雅简洁。</p>\n<h3 id=\"EventBus-的组成\"><a href=\"#EventBus-的组成\" class=\"headerlink\" title=\"EventBus 的组成\"></a>EventBus 的组成</h3><p><img src=\"/imgs/EventBus-Publish-Subscribe.png\" alt=\"EventBus-Publish-Subscribe\"></p>\n<p>从上图我们可以看到，EventBus 作为事件总线，有3个重要做成部分：</p>\n<ul>\n<li>Publisher: 发布者。 表示数据的持有者，通过eventbus.post(obj)方法将数据传递出去，然而并不关心数据是否被接受，以及数据的传递过程。获取方法也很简单：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventBus.getDefault();</div><div class=\"line\">``` </div><div class=\"line\">- Event:事件。这里我习惯称之为数据，就是你所要传递出得对象。</div><div class=\"line\">- Subscriber: 订阅者。 或者好理解点的话，可是称之为接收者，数据将通过这些函数来进行接受。EventBus这里提供了四个函数且只能用这四个：**onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync .**当然，上面的方法是对于EventBus2.0中用到的 下面会重点讲一下3.0的用法。</div><div class=\"line\"></div><div class=\"line\">### EventBus 四个Subscriber</div><div class=\"line\"></div><div class=\"line\">首先在将四种方式之前不得不说一下ThreadMode, ThreadMode 是EventBus中一个很重要的概念，其本身是一个enum，他同样提供了四个默认属性值：Async，BackgroundThread，MainThread，PostThread；而在3.0中则改为</div><div class=\"line\">ASYNC，BACKGROUND，MAIN，POSTING。分别对应四个方法。</div><div class=\"line\"></div><div class=\"line\">先来说一下2.0中的Subscriber</div><div class=\"line\">&gt;**onEvent**</div><div class=\"line\">对应 PostThread，当使用onEvent作为订阅函数时，发布者在哪个线程发布事件，onEvent就会在**哪个线程**接收事件。因为函数执行的线程不确定，这就要求用户 最好不要执行耗时操作，可能会出现线程阻塞或者事件分发不及时的问题。</div><div class=\"line\">注意一点：**方法的修饰符 最好 使用 public **</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>public void onEvent（Object obj）{</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;** onEventMainThread**</div><div class=\"line\">对应 MainThread，当使用onEventMainThread作为订阅函数时，发布者不管在哪个线程发布事件，onEventMainThread都会在**主线程**接收事件。这就要求用户 一定不要执行耗时操作，不然会造成线程阻塞。</div></pre></td></tr></table></figure></p>\n<p>public void onEventMainThread（Object obj）{</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt;** onEventBackground**</div><div class=\"line\">对应 BackgroundThread，当使用onEventBackground作为订阅函数时，发布者如果在主线程发布事件，onEventBackground将会**新开一个子线程**并接收事件，但是如果是在子线程中发布事件，onEventBackground将会直接在**该子线程**中接受事件。</div></pre></td></tr></table></figure></p>\n<p>public void onEventBackground（Object obj）{</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt;** onEventAsync**</div><div class=\"line\">对应 Async，当使用onEventAsync作为订阅函数时，发布者无论在哪个线程发布事件，onEventAsync都会**新开一个子线程**并接收事件。</div></pre></td></tr></table></figure></p>\n<p>public void onEventAsync（Object obj）{</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**而相对来说，3.0 改变对需要固定函数名的设定，提供了一种新的形式，改用注解@Subscribe ，在使用中更加灵活，而且 这里 ThreadMode 将被直接使用。**</div><div class=\"line\">&gt; onEvent 函数的实现</div></pre></td></tr></table></figure></p>\n<p>//发布线程中，调用<br>@Subscribe(threadMode = ThreadMode.POSTING)<br>public void eventbusPosting(Object object){<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; onEventMainThread 函数的实现</div></pre></td></tr></table></figure></p>\n<p>//主线程中，调用<br>@Subscribe(threadMode = ThreadMode.MAIN)<br>public void eventbusMain(Object object){<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; onEventBackground 函数的实现</div></pre></td></tr></table></figure></p>\n<p>//发布线程为主线程，新开子线程，调用<br>//发布线程为子线程，该线程调用<br>@Subscribe(threadMode = ThreadMode.BACKGROUND)<br>public void eventbusBackground(Object object){<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; onEventAsync 函数的实现</div></pre></td></tr></table></figure></p>\n<p>//新开子线程调用<br>@Subscribe(threadMode = ThreadMode.ASYNC)<br>public void eventbusAsync(Object object){<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">**最后说一点：EventBus 并没有摒弃固定函数名的形式，开发者仍旧可以使用这种形式，不过在使用过程中必须要 添加注解 @ Subscribe 但不用指定ThreadMode**</div><div class=\"line\"></div><div class=\"line\">### EventBus的基本使用</div><div class=\"line\"></div><div class=\"line\">#### 引入</div></pre></td></tr></table></figure></p>\n<p>compile ‘org.greenrobot:eventbus:3.0.0’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 定义事件</div></pre></td></tr></table></figure></p>\n<p>public class MessageEvent { /<em> Additional fields if needed </em>/ }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 注册订阅者</div></pre></td></tr></table></figure></p>\n<p>EventBus.getDefault().register(this);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 发送事件</div></pre></td></tr></table></figure></p>\n<p>EventBus.getDefault().post(messageEvent);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 接收事件</div></pre></td></tr></table></figure></p>\n<p>//eventbus2.0形式<br>public void onEvent(MessageEvent event){</p>\n<p>}<br>或者<br>//eventbus3.0形式<br>@Subscribe(threadMode = ThreadMode.POSTING)<br>public void postingME(MessageEvent event){</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 注销订阅</div></pre></td></tr></table></figure></p>\n<p>EventBus.getDefault().unregister(this);<br>```</p>\n","excerpt":"<p><img src=\"/imgs/EventBus-Top.jpg\" alt=\"配图\"></p>\n<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>以前开发一直在用 EventBus2.0，最近想学点新东西，看到EventBus竟然出3.0了，看时间是早就有了，但一直没接触过，就学习学习，也顺便谈谈我在使用两个版本时，对它们的不同的感受。<br>开讲之前先付一下源码地址：<a href=\"https://github.com/greenrobot/EventBus\">https://github.com/greenrobot/EventBus</a><br>","more":"</p>\n<h3 id=\"介绍一下：\"><a href=\"#介绍一下：\" class=\"headerlink\" title=\"介绍一下：\"></a>介绍一下：</h3><p>EventBus是由大名鼎鼎的greenrobot出品的一个用于Android中事件发布/订阅的库。简单点说就是用于Fragment，Activity，Service，线程之间进行数据传递，它为开发者提供除了 intent、handler、boardcast这几种传递数据的方式之外的一种选择，其优点在于 几乎不怎么消化资源，并且代码优雅简洁。</p>\n<h3 id=\"EventBus-的组成\"><a href=\"#EventBus-的组成\" class=\"headerlink\" title=\"EventBus 的组成\"></a>EventBus 的组成</h3><p><img src=\"/imgs/EventBus-Publish-Subscribe.png\" alt=\"EventBus-Publish-Subscribe\"></p>\n<p>从上图我们可以看到，EventBus 作为事件总线，有3个重要做成部分：</p>\n<ul>\n<li>Publisher: 发布者。 表示数据的持有者，通过eventbus.post(obj)方法将数据传递出去，然而并不关心数据是否被接受，以及数据的传递过程。获取方法也很简单：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventBus.getDefault();</div><div class=\"line\">``` </div><div class=\"line\">- Event:事件。这里我习惯称之为数据，就是你所要传递出得对象。</div><div class=\"line\">- Subscriber: 订阅者。 或者好理解点的话，可是称之为接收者，数据将通过这些函数来进行接受。EventBus这里提供了四个函数且只能用这四个：**onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync .**当然，上面的方法是对于EventBus2.0中用到的 下面会重点讲一下3.0的用法。</div><div class=\"line\"></div><div class=\"line\">### EventBus 四个Subscriber</div><div class=\"line\"></div><div class=\"line\">首先在将四种方式之前不得不说一下ThreadMode, ThreadMode 是EventBus中一个很重要的概念，其本身是一个enum，他同样提供了四个默认属性值：Async，BackgroundThread，MainThread，PostThread；而在3.0中则改为</div><div class=\"line\">ASYNC，BACKGROUND，MAIN，POSTING。分别对应四个方法。</div><div class=\"line\"></div><div class=\"line\">先来说一下2.0中的Subscriber</div><div class=\"line\">&gt;**onEvent**</div><div class=\"line\">对应 PostThread，当使用onEvent作为订阅函数时，发布者在哪个线程发布事件，onEvent就会在**哪个线程**接收事件。因为函数执行的线程不确定，这就要求用户 最好不要执行耗时操作，可能会出现线程阻塞或者事件分发不及时的问题。</div><div class=\"line\">注意一点：**方法的修饰符 最好 使用 public **</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>public void onEvent（Object obj）{</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;** onEventMainThread**</div><div class=\"line\">对应 MainThread，当使用onEventMainThread作为订阅函数时，发布者不管在哪个线程发布事件，onEventMainThread都会在**主线程**接收事件。这就要求用户 一定不要执行耗时操作，不然会造成线程阻塞。</div></pre></td></tr></table></figure></p>\n<p>public void onEventMainThread（Object obj）{</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt;** onEventBackground**</div><div class=\"line\">对应 BackgroundThread，当使用onEventBackground作为订阅函数时，发布者如果在主线程发布事件，onEventBackground将会**新开一个子线程**并接收事件，但是如果是在子线程中发布事件，onEventBackground将会直接在**该子线程**中接受事件。</div></pre></td></tr></table></figure></p>\n<p>public void onEventBackground（Object obj）{</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt;** onEventAsync**</div><div class=\"line\">对应 Async，当使用onEventAsync作为订阅函数时，发布者无论在哪个线程发布事件，onEventAsync都会**新开一个子线程**并接收事件。</div></pre></td></tr></table></figure></p>\n<p>public void onEventAsync（Object obj）{</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**而相对来说，3.0 改变对需要固定函数名的设定，提供了一种新的形式，改用注解@Subscribe ，在使用中更加灵活，而且 这里 ThreadMode 将被直接使用。**</div><div class=\"line\">&gt; onEvent 函数的实现</div></pre></td></tr></table></figure></p>\n<p>//发布线程中，调用<br>@Subscribe(threadMode = ThreadMode.POSTING)<br>public void eventbusPosting(Object object){<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; onEventMainThread 函数的实现</div></pre></td></tr></table></figure></p>\n<p>//主线程中，调用<br>@Subscribe(threadMode = ThreadMode.MAIN)<br>public void eventbusMain(Object object){<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; onEventBackground 函数的实现</div></pre></td></tr></table></figure></p>\n<p>//发布线程为主线程，新开子线程，调用<br>//发布线程为子线程，该线程调用<br>@Subscribe(threadMode = ThreadMode.BACKGROUND)<br>public void eventbusBackground(Object object){<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; onEventAsync 函数的实现</div></pre></td></tr></table></figure></p>\n<p>//新开子线程调用<br>@Subscribe(threadMode = ThreadMode.ASYNC)<br>public void eventbusAsync(Object object){<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">**最后说一点：EventBus 并没有摒弃固定函数名的形式，开发者仍旧可以使用这种形式，不过在使用过程中必须要 添加注解 @ Subscribe 但不用指定ThreadMode**</div><div class=\"line\"></div><div class=\"line\">### EventBus的基本使用</div><div class=\"line\"></div><div class=\"line\">#### 引入</div></pre></td></tr></table></figure></p>\n<p>compile ‘org.greenrobot:eventbus:3.0.0’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 定义事件</div></pre></td></tr></table></figure></p>\n<p>public class MessageEvent { /<em> Additional fields if needed </em>/ }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 注册订阅者</div></pre></td></tr></table></figure></p>\n<p>EventBus.getDefault().register(this);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 发送事件</div></pre></td></tr></table></figure></p>\n<p>EventBus.getDefault().post(messageEvent);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 接收事件</div></pre></td></tr></table></figure></p>\n<p>//eventbus2.0形式<br>public void onEvent(MessageEvent event){</p>\n<p>}<br>或者<br>//eventbus3.0形式<br>@Subscribe(threadMode = ThreadMode.POSTING)<br>public void postingME(MessageEvent event){</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 注销订阅</div></pre></td></tr></table></figure></p>\n<p>EventBus.getDefault().unregister(this);<br>```</p>"},{"title":"Rxjava学习：初识Rxjava","date":"2016-08-23T02:32:39.000Z","description":null,"_content":"\n\n### 前言\n在过去的一年里，出现大量优秀的框架，火的不行，我也是从网上了解到Rx，特意搜索了相关文章，我也是通过它初步了解了Rxjava, 通过使用也慢慢领会到了其独特的魅力。\n<!-- more-->\n> *先谈谈我对Rxjava的认识*\n\n首先说一下使用的感受：作为一只程序猿，最烦的就是那无穷无尽的for循环，以及那看起来都有点丧心病狂的 格式缩进，而如果使用Rxjava来进行数据处理的话，完全没有这方面的问题，你只要依次实现每一个方法就可以迅速获得同样的效果。\n\n\n这里借鉴一下 [给 Android 开发者的 RxJava 详解](http://gank.io/post/560e15be2dca930e00da1083)一文中的例子，来给大家说明一下： \n\n*假设有这样一个需求：界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种：*\n\n```\nnew Thread() {\n    @Override\n    public void run() {\n        super.run();\n        for (File folder : folders) {\n            File[] files = folder.listFiles();\n            for (File file : files) {\n                if (file.getName().endsWith(\".png\")) {\n                    final Bitmap bitmap = getBitmapFromFile(file);\n                    getActivity().runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageCollectorView.addImage(bitmap);\n                        }\n                    });\n                }\n            }\n        }\n    }\n}.start();\n```\n而如果使用 RxJava ，实现方式是这样的：\n```\nObservable.from(folders)\n    .flatMap(new Func1<File, Observable<File>>() {\n        @Override\n        public Observable<File> call(File file) {\n            return Observable.from(file.listFiles());\n        }\n    })\n    .filter(new Func1<File, Boolean>() {\n        @Override\n        public Boolean call(File file) {\n            return file.getName().endsWith(\".png\");\n        }\n    })\n    .map(new Func1<File, Bitmap>() {\n        @Override\n        public Bitmap call(File file) {\n            return getBitmapFromFile(file);\n        }\n    })\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Action1<Bitmap>() {\n        @Override\n        public void call(Bitmap bitmap) {\n            imageCollectorView.addImage(bitmap);\n        }\n    });\n```\n\n这样，大家就可以理解， RxJava 的优秀在于其可读性，只要熟悉编写习惯后不管过多久再来看这部分代码，仍然可以很快的理解，而上面的各种for循环写出来的代码，并不具备这样的属性。\n\n>*下面就来简单的讲一下Rxjava的使用*\n\n### 引入RxJava\n\nRxJava 支持Java 6或者更新的版本,引入前请更新到Java 6或以上版本。\n\n```\ncompile 'io.reactivex:rxandroid:1.2.1'\ncompile 'io.reactivex:rxjava:1.1.8'\n```\nRxAndroid 是 Android 开发中使用 RxJava 必备元素，虽然里面只是提供了简单的两个功能。 AndroidSchedulers.mainThread() \n和 AndroidSchedulers.handlerThread(handler) ，但这确是 Android 开发中最核心的功能之一。\n\n### Rxjava基本概念\n\n下面来谈谈Rxjava几个基本概念的介绍:\n- Observer（观察者）\n- Observable （被观察者）\n- subscribe(* observer *) （订阅）\n\n>Observer（观察者）\nObserver 提供一组不同的事件，并对各个事件进行实现，不关心事件何时发生，只决定事件触发的时候将有怎样的行为。\n\n本质是一个接口，提供了三个方法，需要实现。\n\n- onNext(Object o): 事件队列中，RxJava 每完成一次事件都会通过调用onNext(Object o), 对结果进行相应的操作。\n\n- onCompleted(): 当整个事件队列完成所有的数据处理时，其将被调用。\n\n- onError(): 在整个事件队列中，只要有一个事件处理出现问题，其将被调用，并放弃对剩下事件的处理。\n\n```\nSubscriber<String> subscriber = new Subscriber<String>() {\n  @Override\n  public void onNext(String s) {\n      Log.d(tag, \"Item: \" + s);\n  }\n\n  @Override\n  public void onCompleted() {\n      Log.d(tag, \"Completed!\");\n  }\n\n  @Override\n  public void onError(Throwable e) {\n      Log.d(tag, \"Error!\");\n  }\n};\n```\n\n> Observable（被观察者）\nObservable 提供事件触发的场景，即决定什么时候触发事件和此时该触发什么事件，不关心事件的具体实现。\n\n其提供了多种初始化，创建对象的方法：\n- create()\n```\n//使用Observable.create()创建被观察者\nObservable observable1 = Observable.create(new Observable.OnSubscribe<String>() {\n            @Override\n            public void call(Subscriber<? super String> subscriber) {\n                subscriber.onNext(\"Hello\");\n                subscriber.onNext(\"Wrold\");\n                subscriber.onCompleted();\n            }\n        });\n```\n\n- just(T...)\n```\nObservable observable2 = Observable.just(\"Hello\", \"World\");\n```\n- from(T[]) \n```\nString [] words = {\"Hello\", \"World\"};\nObservable observable3 = Observable.from(words);\n```\n或者\n```\nList<String> list = new ArrayList<String>();\nlist.add(\"Hellow\");\nlist.add(\"Wrold\");\nObservable observable4 = Observable.from(list);\n```\n\n>subscribe(* observer *) （订阅）\n创建Observable和Observer之后，通过subscribe()方法将它们结合起来。\n\n### 小结\n\n对Rxjava作了一个简单的介绍，从基础知识开始讲起可能比较枯燥，没有多少实践，但是基础的重要性不言而喻，尤其对于Rxjava来说，其代码的编写习惯与我们平常不太一样，其链式的风格更加简洁，当你慢慢习惯，你将领会其独特的魅力。\n","source":"_posts/Rxjava学习：初识Rxjava.md","raw":"---\ntitle: Rxjava学习：初识Rxjava\ndate: 2016-08-23 10:32:39\ntags: [Rxjava, RxAndroid] \ndescription: \ncategories: Rxjava学习\n---\n\n\n### 前言\n在过去的一年里，出现大量优秀的框架，火的不行，我也是从网上了解到Rx，特意搜索了相关文章，我也是通过它初步了解了Rxjava, 通过使用也慢慢领会到了其独特的魅力。\n<!-- more-->\n> *先谈谈我对Rxjava的认识*\n\n首先说一下使用的感受：作为一只程序猿，最烦的就是那无穷无尽的for循环，以及那看起来都有点丧心病狂的 格式缩进，而如果使用Rxjava来进行数据处理的话，完全没有这方面的问题，你只要依次实现每一个方法就可以迅速获得同样的效果。\n\n\n这里借鉴一下 [给 Android 开发者的 RxJava 详解](http://gank.io/post/560e15be2dca930e00da1083)一文中的例子，来给大家说明一下： \n\n*假设有这样一个需求：界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种：*\n\n```\nnew Thread() {\n    @Override\n    public void run() {\n        super.run();\n        for (File folder : folders) {\n            File[] files = folder.listFiles();\n            for (File file : files) {\n                if (file.getName().endsWith(\".png\")) {\n                    final Bitmap bitmap = getBitmapFromFile(file);\n                    getActivity().runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageCollectorView.addImage(bitmap);\n                        }\n                    });\n                }\n            }\n        }\n    }\n}.start();\n```\n而如果使用 RxJava ，实现方式是这样的：\n```\nObservable.from(folders)\n    .flatMap(new Func1<File, Observable<File>>() {\n        @Override\n        public Observable<File> call(File file) {\n            return Observable.from(file.listFiles());\n        }\n    })\n    .filter(new Func1<File, Boolean>() {\n        @Override\n        public Boolean call(File file) {\n            return file.getName().endsWith(\".png\");\n        }\n    })\n    .map(new Func1<File, Bitmap>() {\n        @Override\n        public Bitmap call(File file) {\n            return getBitmapFromFile(file);\n        }\n    })\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Action1<Bitmap>() {\n        @Override\n        public void call(Bitmap bitmap) {\n            imageCollectorView.addImage(bitmap);\n        }\n    });\n```\n\n这样，大家就可以理解， RxJava 的优秀在于其可读性，只要熟悉编写习惯后不管过多久再来看这部分代码，仍然可以很快的理解，而上面的各种for循环写出来的代码，并不具备这样的属性。\n\n>*下面就来简单的讲一下Rxjava的使用*\n\n### 引入RxJava\n\nRxJava 支持Java 6或者更新的版本,引入前请更新到Java 6或以上版本。\n\n```\ncompile 'io.reactivex:rxandroid:1.2.1'\ncompile 'io.reactivex:rxjava:1.1.8'\n```\nRxAndroid 是 Android 开发中使用 RxJava 必备元素，虽然里面只是提供了简单的两个功能。 AndroidSchedulers.mainThread() \n和 AndroidSchedulers.handlerThread(handler) ，但这确是 Android 开发中最核心的功能之一。\n\n### Rxjava基本概念\n\n下面来谈谈Rxjava几个基本概念的介绍:\n- Observer（观察者）\n- Observable （被观察者）\n- subscribe(* observer *) （订阅）\n\n>Observer（观察者）\nObserver 提供一组不同的事件，并对各个事件进行实现，不关心事件何时发生，只决定事件触发的时候将有怎样的行为。\n\n本质是一个接口，提供了三个方法，需要实现。\n\n- onNext(Object o): 事件队列中，RxJava 每完成一次事件都会通过调用onNext(Object o), 对结果进行相应的操作。\n\n- onCompleted(): 当整个事件队列完成所有的数据处理时，其将被调用。\n\n- onError(): 在整个事件队列中，只要有一个事件处理出现问题，其将被调用，并放弃对剩下事件的处理。\n\n```\nSubscriber<String> subscriber = new Subscriber<String>() {\n  @Override\n  public void onNext(String s) {\n      Log.d(tag, \"Item: \" + s);\n  }\n\n  @Override\n  public void onCompleted() {\n      Log.d(tag, \"Completed!\");\n  }\n\n  @Override\n  public void onError(Throwable e) {\n      Log.d(tag, \"Error!\");\n  }\n};\n```\n\n> Observable（被观察者）\nObservable 提供事件触发的场景，即决定什么时候触发事件和此时该触发什么事件，不关心事件的具体实现。\n\n其提供了多种初始化，创建对象的方法：\n- create()\n```\n//使用Observable.create()创建被观察者\nObservable observable1 = Observable.create(new Observable.OnSubscribe<String>() {\n            @Override\n            public void call(Subscriber<? super String> subscriber) {\n                subscriber.onNext(\"Hello\");\n                subscriber.onNext(\"Wrold\");\n                subscriber.onCompleted();\n            }\n        });\n```\n\n- just(T...)\n```\nObservable observable2 = Observable.just(\"Hello\", \"World\");\n```\n- from(T[]) \n```\nString [] words = {\"Hello\", \"World\"};\nObservable observable3 = Observable.from(words);\n```\n或者\n```\nList<String> list = new ArrayList<String>();\nlist.add(\"Hellow\");\nlist.add(\"Wrold\");\nObservable observable4 = Observable.from(list);\n```\n\n>subscribe(* observer *) （订阅）\n创建Observable和Observer之后，通过subscribe()方法将它们结合起来。\n\n### 小结\n\n对Rxjava作了一个简单的介绍，从基础知识开始讲起可能比较枯燥，没有多少实践，但是基础的重要性不言而喻，尤其对于Rxjava来说，其代码的编写习惯与我们平常不太一样，其链式的风格更加简洁，当你慢慢习惯，你将领会其独特的魅力。\n","slug":"Rxjava学习：初识Rxjava","published":1,"updated":"2016-09-02T08:57:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovdux000fbqc681tfrbyv","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在过去的一年里，出现大量优秀的框架，火的不行，我也是从网上了解到Rx，特意搜索了相关文章，我也是通过它初步了解了Rxjava, 通过使用也慢慢领会到了其独特的魅力。<br><a id=\"more\"></a></p>\n<blockquote>\n<p><em>先谈谈我对Rxjava的认识</em></p>\n</blockquote>\n<p>首先说一下使用的感受：作为一只程序猿，最烦的就是那无穷无尽的for循环，以及那看起来都有点丧心病狂的 格式缩进，而如果使用Rxjava来进行数据处理的话，完全没有这方面的问题，你只要依次实现每一个方法就可以迅速获得同样的效果。</p>\n<p>这里借鉴一下 <a href=\"http://gank.io/post/560e15be2dca930e00da1083\" target=\"_blank\" rel=\"external\">给 Android 开发者的 RxJava 详解</a>一文中的例子，来给大家说明一下： </p>\n<p><em>假设有这样一个需求：界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Thread() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        super.run();</div><div class=\"line\">        for (File folder : folders) &#123;</div><div class=\"line\">            File[] files = folder.listFiles();</div><div class=\"line\">            for (File file : files) &#123;</div><div class=\"line\">                if (file.getName().endsWith(&quot;.png&quot;)) &#123;</div><div class=\"line\">                    final Bitmap bitmap = getBitmapFromFile(file);</div><div class=\"line\">                    getActivity().runOnUiThread(new Runnable() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void run() &#123;</div><div class=\"line\">                            imageCollectorView.addImage(bitmap);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;.start();</div></pre></td></tr></table></figure>\n<p>而如果使用 RxJava ，实现方式是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(folders)</div><div class=\"line\">    .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Observable&lt;File&gt; call(File file) &#123;</div><div class=\"line\">            return Observable.from(file.listFiles());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .filter(new Func1&lt;File, Boolean&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Boolean call(File file) &#123;</div><div class=\"line\">            return file.getName().endsWith(&quot;.png&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .map(new Func1&lt;File, Bitmap&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Bitmap call(File file) &#123;</div><div class=\"line\">            return getBitmapFromFile(file);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">    .subscribe(new Action1&lt;Bitmap&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void call(Bitmap bitmap) &#123;</div><div class=\"line\">            imageCollectorView.addImage(bitmap);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>这样，大家就可以理解， RxJava 的优秀在于其可读性，只要熟悉编写习惯后不管过多久再来看这部分代码，仍然可以很快的理解，而上面的各种for循环写出来的代码，并不具备这样的属性。</p>\n<blockquote>\n<p><em>下面就来简单的讲一下Rxjava的使用</em></p>\n</blockquote>\n<h3 id=\"引入RxJava\"><a href=\"#引入RxJava\" class=\"headerlink\" title=\"引入RxJava\"></a>引入RxJava</h3><p>RxJava 支持Java 6或者更新的版本,引入前请更新到Java 6或以上版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile &apos;io.reactivex:rxandroid:1.2.1&apos;</div><div class=\"line\">compile &apos;io.reactivex:rxjava:1.1.8&apos;</div></pre></td></tr></table></figure>\n<p>RxAndroid 是 Android 开发中使用 RxJava 必备元素，虽然里面只是提供了简单的两个功能。 AndroidSchedulers.mainThread()<br>和 AndroidSchedulers.handlerThread(handler) ，但这确是 Android 开发中最核心的功能之一。</p>\n<h3 id=\"Rxjava基本概念\"><a href=\"#Rxjava基本概念\" class=\"headerlink\" title=\"Rxjava基本概念\"></a>Rxjava基本概念</h3><p>下面来谈谈Rxjava几个基本概念的介绍:</p>\n<ul>\n<li>Observer（观察者）</li>\n<li>Observable （被观察者）</li>\n<li>subscribe(<em> observer </em>) （订阅）</li>\n</ul>\n<blockquote>\n<p>Observer（观察者）<br>Observer 提供一组不同的事件，并对各个事件进行实现，不关心事件何时发生，只决定事件触发的时候将有怎样的行为。</p>\n</blockquote>\n<p>本质是一个接口，提供了三个方法，需要实现。</p>\n<ul>\n<li><p>onNext(Object o): 事件队列中，RxJava 每完成一次事件都会通过调用onNext(Object o), 对结果进行相应的操作。</p>\n</li>\n<li><p>onCompleted(): 当整个事件队列完成所有的数据处理时，其将被调用。</p>\n</li>\n<li><p>onError(): 在整个事件队列中，只要有一个事件处理出现问题，其将被调用，并放弃对剩下事件的处理。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">  @Override</div><div class=\"line\">  public void onNext(String s) &#123;</div><div class=\"line\">      Log.d(tag, &quot;Item: &quot; + s);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void onCompleted() &#123;</div><div class=\"line\">      Log.d(tag, &quot;Completed!&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void onError(Throwable e) &#123;</div><div class=\"line\">      Log.d(tag, &quot;Error!&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Observable（被观察者）<br>Observable 提供事件触发的场景，即决定什么时候触发事件和此时该触发什么事件，不关心事件的具体实现。</p>\n</blockquote>\n<p>其提供了多种初始化，创建对象的方法：</p>\n<ul>\n<li><p>create()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//使用Observable.create()创建被观察者</div><div class=\"line\">Observable observable1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class=\"line\">                subscriber.onNext(&quot;Hello&quot;);</div><div class=\"line\">                subscriber.onNext(&quot;Wrold&quot;);</div><div class=\"line\">                subscriber.onCompleted();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>just(T…)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable observable2 = Observable.just(&quot;Hello&quot;, &quot;World&quot;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>from(T[]) </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String [] words = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;</div><div class=\"line\">Observable observable3 = Observable.from(words);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>或者<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class=\"line\">list.add(&quot;Hellow&quot;);</div><div class=\"line\">list.add(&quot;Wrold&quot;);</div><div class=\"line\">Observable observable4 = Observable.from(list);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>subscribe(<em> observer </em>) （订阅）<br>创建Observable和Observer之后，通过subscribe()方法将它们结合起来。</p>\n</blockquote>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>对Rxjava作了一个简单的介绍，从基础知识开始讲起可能比较枯燥，没有多少实践，但是基础的重要性不言而喻，尤其对于Rxjava来说，其代码的编写习惯与我们平常不太一样，其链式的风格更加简洁，当你慢慢习惯，你将领会其独特的魅力。</p>\n","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在过去的一年里，出现大量优秀的框架，火的不行，我也是从网上了解到Rx，特意搜索了相关文章，我也是通过它初步了解了Rxjava, 通过使用也慢慢领会到了其独特的魅力。<br>","more":"</p>\n<blockquote>\n<p><em>先谈谈我对Rxjava的认识</em></p>\n</blockquote>\n<p>首先说一下使用的感受：作为一只程序猿，最烦的就是那无穷无尽的for循环，以及那看起来都有点丧心病狂的 格式缩进，而如果使用Rxjava来进行数据处理的话，完全没有这方面的问题，你只要依次实现每一个方法就可以迅速获得同样的效果。</p>\n<p>这里借鉴一下 <a href=\"http://gank.io/post/560e15be2dca930e00da1083\">给 Android 开发者的 RxJava 详解</a>一文中的例子，来给大家说明一下： </p>\n<p><em>假设有这样一个需求：界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Thread() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        super.run();</div><div class=\"line\">        for (File folder : folders) &#123;</div><div class=\"line\">            File[] files = folder.listFiles();</div><div class=\"line\">            for (File file : files) &#123;</div><div class=\"line\">                if (file.getName().endsWith(&quot;.png&quot;)) &#123;</div><div class=\"line\">                    final Bitmap bitmap = getBitmapFromFile(file);</div><div class=\"line\">                    getActivity().runOnUiThread(new Runnable() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void run() &#123;</div><div class=\"line\">                            imageCollectorView.addImage(bitmap);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;.start();</div></pre></td></tr></table></figure>\n<p>而如果使用 RxJava ，实现方式是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(folders)</div><div class=\"line\">    .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Observable&lt;File&gt; call(File file) &#123;</div><div class=\"line\">            return Observable.from(file.listFiles());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .filter(new Func1&lt;File, Boolean&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Boolean call(File file) &#123;</div><div class=\"line\">            return file.getName().endsWith(&quot;.png&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .map(new Func1&lt;File, Bitmap&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Bitmap call(File file) &#123;</div><div class=\"line\">            return getBitmapFromFile(file);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">    .subscribe(new Action1&lt;Bitmap&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void call(Bitmap bitmap) &#123;</div><div class=\"line\">            imageCollectorView.addImage(bitmap);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>这样，大家就可以理解， RxJava 的优秀在于其可读性，只要熟悉编写习惯后不管过多久再来看这部分代码，仍然可以很快的理解，而上面的各种for循环写出来的代码，并不具备这样的属性。</p>\n<blockquote>\n<p><em>下面就来简单的讲一下Rxjava的使用</em></p>\n</blockquote>\n<h3 id=\"引入RxJava\"><a href=\"#引入RxJava\" class=\"headerlink\" title=\"引入RxJava\"></a>引入RxJava</h3><p>RxJava 支持Java 6或者更新的版本,引入前请更新到Java 6或以上版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile &apos;io.reactivex:rxandroid:1.2.1&apos;</div><div class=\"line\">compile &apos;io.reactivex:rxjava:1.1.8&apos;</div></pre></td></tr></table></figure>\n<p>RxAndroid 是 Android 开发中使用 RxJava 必备元素，虽然里面只是提供了简单的两个功能。 AndroidSchedulers.mainThread()<br>和 AndroidSchedulers.handlerThread(handler) ，但这确是 Android 开发中最核心的功能之一。</p>\n<h3 id=\"Rxjava基本概念\"><a href=\"#Rxjava基本概念\" class=\"headerlink\" title=\"Rxjava基本概念\"></a>Rxjava基本概念</h3><p>下面来谈谈Rxjava几个基本概念的介绍:</p>\n<ul>\n<li>Observer（观察者）</li>\n<li>Observable （被观察者）</li>\n<li>subscribe(<em> observer </em>) （订阅）</li>\n</ul>\n<blockquote>\n<p>Observer（观察者）<br>Observer 提供一组不同的事件，并对各个事件进行实现，不关心事件何时发生，只决定事件触发的时候将有怎样的行为。</p>\n</blockquote>\n<p>本质是一个接口，提供了三个方法，需要实现。</p>\n<ul>\n<li><p>onNext(Object o): 事件队列中，RxJava 每完成一次事件都会通过调用onNext(Object o), 对结果进行相应的操作。</p>\n</li>\n<li><p>onCompleted(): 当整个事件队列完成所有的数据处理时，其将被调用。</p>\n</li>\n<li><p>onError(): 在整个事件队列中，只要有一个事件处理出现问题，其将被调用，并放弃对剩下事件的处理。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">  @Override</div><div class=\"line\">  public void onNext(String s) &#123;</div><div class=\"line\">      Log.d(tag, &quot;Item: &quot; + s);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void onCompleted() &#123;</div><div class=\"line\">      Log.d(tag, &quot;Completed!&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void onError(Throwable e) &#123;</div><div class=\"line\">      Log.d(tag, &quot;Error!&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Observable（被观察者）<br>Observable 提供事件触发的场景，即决定什么时候触发事件和此时该触发什么事件，不关心事件的具体实现。</p>\n</blockquote>\n<p>其提供了多种初始化，创建对象的方法：</p>\n<ul>\n<li><p>create()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//使用Observable.create()创建被观察者</div><div class=\"line\">Observable observable1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class=\"line\">                subscriber.onNext(&quot;Hello&quot;);</div><div class=\"line\">                subscriber.onNext(&quot;Wrold&quot;);</div><div class=\"line\">                subscriber.onCompleted();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>just(T…)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable observable2 = Observable.just(&quot;Hello&quot;, &quot;World&quot;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>from(T[]) </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String [] words = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;</div><div class=\"line\">Observable observable3 = Observable.from(words);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>或者<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class=\"line\">list.add(&quot;Hellow&quot;);</div><div class=\"line\">list.add(&quot;Wrold&quot;);</div><div class=\"line\">Observable observable4 = Observable.from(list);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>subscribe(<em> observer </em>) （订阅）<br>创建Observable和Observer之后，通过subscribe()方法将它们结合起来。</p>\n</blockquote>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>对Rxjava作了一个简单的介绍，从基础知识开始讲起可能比较枯燥，没有多少实践，但是基础的重要性不言而喻，尤其对于Rxjava来说，其代码的编写习惯与我们平常不太一样，其链式的风格更加简洁，当你慢慢习惯，你将领会其独特的魅力。</p>"},{"title":"消息栏通知Notification的那些事儿","date":"2016-12-01T01:26:12.000Z","_content":"#### 前言\n最近在开发过程中，用到了Notification的功能，需要实现一个自定义的布局。实现方式相信大家也都知道，就是通过RemoteViews来实现。但是在开发过程中还是遇到不少问题。\n<!-- more-->\n首先，还是有必要说明一下，**RemoteViews**主要被用于AppWidget和Notification，它描述一个在其它进程中显示的View。\n\n#### RemoteViews 使用过程中遇到的问题\n\n> 首先是关于 RemoteViews 设置的问题\n\n```\nNotification notification = new NotificationCompat.Builder(this)\n                .setContent(remoteViews)\n                .setSmallIcon(R.mipmap.ic_launcher)\n                .setTicker(\"您有新短消息，请注意查收！\").build();\n```\nNotificationCompat.Builder是有提供setContent的方法来设置RemoteViews的。然而存在一个问题，通过setContent()方法获得的Notification是固定高度的。如果View的高度比默认高度要大的话，就会有一部分显示不出来。\n\n那么如何设置能够不存在高度限定呢？ 实际上也简单。\n```\nif(android.os.Build.VERSION.SDK_INT >= 16) {\n            notification.bigContentView = remoteViews;\n        }\n notification.contentView = remoteViews;\n```\nandroid 在sdk16的时候引入了通知的展开和收起的功能，通过两个手指滑动操作，这里 bigContentView 表示展开时的显示的View，而contentView 表示收起时显示的View。我们可以通过设置 bigContentView 来完全显示，但仍然需要注意几个点：\n- bigContentView是在sdk16的时候才引入的，所以一定不要忘记判断一下。对于小于16，的则只能定高了。\n\n- 就算是bigContentView 也是有最大高度的，其最大高度是256dp，而contentView 默认情况下高度为64p。\n\n- Notification 使用过程中， .setSmallIcon、setTicker 是一定要设置的。\n\n> 自定义View 对背景色的适配\n\nAndroid通知栏的背景各式各样，不同的ROM都适配有不同的背景。不同的Android版本通知栏背景也不一样，一旦我们为自定义通知上的元素设置了特定背景或颜色，就肯定会带来兼容性问题。\n\n由此可以想到一种方法，将背景设为透明的，然后如果可以找到系统通知栏默认的文字样式，这样就可以显示出同样的效果了。\n\n\n![屏幕快照 2016-11-13 13.01.56.png](/imgs/notification_03.png)\n\nandroid 也确实提供了这样的样式，使用方式也简单,如下面这样设置即可。\n```\nandroid:textAppearance=\"@style/TextAppearance.StatusBar.EventContent.Title\"\n```\n同时还提供了其他样式，如 TextAppearance.StatusBar.EventContent.Time，TextAppearance.StatusBar.EventContent.Info 等都可以试试。\n\n然而这并没有结束，5.0以后的版本，android 又修改了新的默认的样式，所以就需要我们新建layout-v21，添加新的适配文件。\n\n\n![屏幕快照 2016-11-13 13.27.23.png](/imgs/notification_04.png)\n\n设置的方式并没有什么不同\n```\nandroid:textAppearance=\"@android:style/TextAppearance.Material.Notification.Title\"\n```\nok ，大功告成，来看一下效果。\n\n白色背景：\n![截屏_20161113_133535.png](/imgs/notification_01.png)\n\n黑色背景：\n\n![Screenshot_20161113-134026.png](/imgs/notification_02.png)\n\n下面介绍一种大神的方案-大体的方式是： 通过获取系统通知栏Notification默认的标题颜色，然后比对色值，判断出通知栏背景的颜色是黑色域还是白色域，之后就可以选取相应的自定义通知栏。\n\n对这个方案也测试了一下，vivo测试机 通知栏背景色是白色的，然而获得的标题的颜色也是白色的，也就是说 还是会出现 不可预知的问题。总之，学习一下还是可以的。\n\n```\n//逻辑相应代码\npublic class NoficationBar {\n\n    private static final double COLOR_THRESHOLD = 180.0;\n\n    private String DUMMY_TITLE = \"DUMMY_TITLE\";\n    private int titleColor;\n\n    public NoficationBar() {\n    }\n\n    //判断是否Notification背景是否为黑色\n    public boolean isDarkNotificationBar(Context context) {\n        return !isColorSimilar(Color.BLACK, getNotificationTitleColor(context));\n    }\n\n\n\n    //获取Notification 标题的颜色\n    private int getNotificationTitleColor(Context context) {\n        int color = 0;\n        if (context instanceof AppCompatActivity) {\n             color = getNotificationColorCompat(context);\n        } else {\n            color = getNotificationColorInternal(context);\n        }\n        return color;\n    }\n\n    //判断颜色是否相似\n    public boolean isColorSimilar(int baseColor, int color) {\n        int simpleBaseColor = baseColor | 0xff000000;\n        int simpleColor = color | 0xff000000;\n        int baseRed = Color.red(simpleBaseColor) - Color.red(simpleColor);\n        int baseGreen = Color.green(simpleBaseColor) - Color.green(simpleColor);\n        int baseBlue = Color.blue(simpleBaseColor) - Color.blue(simpleColor);\n\n        double value = Math.sqrt(baseRed * baseRed + baseGreen * baseGreen + baseBlue * baseBlue);\n        return value < COLOR_THRESHOLD;\n\n    }\n\n    //获取标题颜色\n    private int getNotificationColorInternal(Context context) {\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);\n        builder.setContentTitle(DUMMY_TITLE);\n        Notification notification = builder.build();\n\n        ViewGroup notificationRoot = (ViewGroup) notification.contentView.apply(context, new FrameLayout(context));\n        TextView title = (TextView) notificationRoot.findViewById(android.R.id.title);\n        if (title == null) { //如果ROM厂商更改了默认的id\n            iteratorView(notificationRoot, new Filter() {\n                @Override\n                public void filter(View view) {\n                    if (view instanceof TextView) {\n                        TextView textView = (TextView) view;\n                        if (DUMMY_TITLE.equals(textView.getText().toString())) {\n\n                            titleColor = textView.getCurrentTextColor();\n                        }\n                    }\n                }\n            });\n            return titleColor;\n        } else {\n\n            return title.getCurrentTextColor();\n        }\n    }\n\n\n    private int getNotificationColorCompat(Context context) {\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);\n        Notification notification = builder.build();\n        int layoutId = notification.contentView.getLayoutId();\n        ViewGroup notificationRoot = (ViewGroup) LayoutInflater.from(context).inflate(layoutId, null);\n        TextView title = (TextView) notificationRoot.findViewById(android.R.id.title);\n        if (title == null) {\n            final List<TextView> textViews = new ArrayList<>();\n            iteratorView(notificationRoot, new Filter() {\n                @Override\n                public void filter(View view) {\n                    if (view instanceof TextView) {\n                        textViews.add((TextView) view);\n                    }\n                }\n            });\n            float minTextSize = Integer.MIN_VALUE;\n            int index = 0;\n            for (int i = 0, j = textViews.size(); i < j; i++) {\n                float currentSize = textViews.get(i).getTextSize();\n                if (currentSize > minTextSize) {\n                    minTextSize = currentSize;\n                    index = i;\n                }\n            }\n            textViews.get(index).setText(DUMMY_TITLE);\n            return textViews.get(index).getCurrentTextColor();\n        } else {\n            return title.getCurrentTextColor();\n        }\n\n    }\n\n\n    private void iteratorView(View view, Filter filter) {\n        if (view == null || filter == null) {\n            return;\n        }\n        filter.filter(view);\n        if (view instanceof ViewGroup) {\n            ViewGroup container = (ViewGroup) view;\n            for (int i = 0, j = container.getChildCount(); i < j; i++) {\n                View child = container.getChildAt(i);\n                iteratorView(child, filter);\n            }\n        }\n\n    }\n\n    interface Filter {\n        void filter(View view);\n    }\n\n}\n```\n\n参考文章： http://www.jianshu.com/p/426d85f34561","source":"_posts/消息栏通知Notification的那些事儿.md","raw":"---\ntitle: 消息栏通知Notification的那些事儿\ndate: 2016-12-01 09:26:12\ntags: Notification\n---\n#### 前言\n最近在开发过程中，用到了Notification的功能，需要实现一个自定义的布局。实现方式相信大家也都知道，就是通过RemoteViews来实现。但是在开发过程中还是遇到不少问题。\n<!-- more-->\n首先，还是有必要说明一下，**RemoteViews**主要被用于AppWidget和Notification，它描述一个在其它进程中显示的View。\n\n#### RemoteViews 使用过程中遇到的问题\n\n> 首先是关于 RemoteViews 设置的问题\n\n```\nNotification notification = new NotificationCompat.Builder(this)\n                .setContent(remoteViews)\n                .setSmallIcon(R.mipmap.ic_launcher)\n                .setTicker(\"您有新短消息，请注意查收！\").build();\n```\nNotificationCompat.Builder是有提供setContent的方法来设置RemoteViews的。然而存在一个问题，通过setContent()方法获得的Notification是固定高度的。如果View的高度比默认高度要大的话，就会有一部分显示不出来。\n\n那么如何设置能够不存在高度限定呢？ 实际上也简单。\n```\nif(android.os.Build.VERSION.SDK_INT >= 16) {\n            notification.bigContentView = remoteViews;\n        }\n notification.contentView = remoteViews;\n```\nandroid 在sdk16的时候引入了通知的展开和收起的功能，通过两个手指滑动操作，这里 bigContentView 表示展开时的显示的View，而contentView 表示收起时显示的View。我们可以通过设置 bigContentView 来完全显示，但仍然需要注意几个点：\n- bigContentView是在sdk16的时候才引入的，所以一定不要忘记判断一下。对于小于16，的则只能定高了。\n\n- 就算是bigContentView 也是有最大高度的，其最大高度是256dp，而contentView 默认情况下高度为64p。\n\n- Notification 使用过程中， .setSmallIcon、setTicker 是一定要设置的。\n\n> 自定义View 对背景色的适配\n\nAndroid通知栏的背景各式各样，不同的ROM都适配有不同的背景。不同的Android版本通知栏背景也不一样，一旦我们为自定义通知上的元素设置了特定背景或颜色，就肯定会带来兼容性问题。\n\n由此可以想到一种方法，将背景设为透明的，然后如果可以找到系统通知栏默认的文字样式，这样就可以显示出同样的效果了。\n\n\n![屏幕快照 2016-11-13 13.01.56.png](/imgs/notification_03.png)\n\nandroid 也确实提供了这样的样式，使用方式也简单,如下面这样设置即可。\n```\nandroid:textAppearance=\"@style/TextAppearance.StatusBar.EventContent.Title\"\n```\n同时还提供了其他样式，如 TextAppearance.StatusBar.EventContent.Time，TextAppearance.StatusBar.EventContent.Info 等都可以试试。\n\n然而这并没有结束，5.0以后的版本，android 又修改了新的默认的样式，所以就需要我们新建layout-v21，添加新的适配文件。\n\n\n![屏幕快照 2016-11-13 13.27.23.png](/imgs/notification_04.png)\n\n设置的方式并没有什么不同\n```\nandroid:textAppearance=\"@android:style/TextAppearance.Material.Notification.Title\"\n```\nok ，大功告成，来看一下效果。\n\n白色背景：\n![截屏_20161113_133535.png](/imgs/notification_01.png)\n\n黑色背景：\n\n![Screenshot_20161113-134026.png](/imgs/notification_02.png)\n\n下面介绍一种大神的方案-大体的方式是： 通过获取系统通知栏Notification默认的标题颜色，然后比对色值，判断出通知栏背景的颜色是黑色域还是白色域，之后就可以选取相应的自定义通知栏。\n\n对这个方案也测试了一下，vivo测试机 通知栏背景色是白色的，然而获得的标题的颜色也是白色的，也就是说 还是会出现 不可预知的问题。总之，学习一下还是可以的。\n\n```\n//逻辑相应代码\npublic class NoficationBar {\n\n    private static final double COLOR_THRESHOLD = 180.0;\n\n    private String DUMMY_TITLE = \"DUMMY_TITLE\";\n    private int titleColor;\n\n    public NoficationBar() {\n    }\n\n    //判断是否Notification背景是否为黑色\n    public boolean isDarkNotificationBar(Context context) {\n        return !isColorSimilar(Color.BLACK, getNotificationTitleColor(context));\n    }\n\n\n\n    //获取Notification 标题的颜色\n    private int getNotificationTitleColor(Context context) {\n        int color = 0;\n        if (context instanceof AppCompatActivity) {\n             color = getNotificationColorCompat(context);\n        } else {\n            color = getNotificationColorInternal(context);\n        }\n        return color;\n    }\n\n    //判断颜色是否相似\n    public boolean isColorSimilar(int baseColor, int color) {\n        int simpleBaseColor = baseColor | 0xff000000;\n        int simpleColor = color | 0xff000000;\n        int baseRed = Color.red(simpleBaseColor) - Color.red(simpleColor);\n        int baseGreen = Color.green(simpleBaseColor) - Color.green(simpleColor);\n        int baseBlue = Color.blue(simpleBaseColor) - Color.blue(simpleColor);\n\n        double value = Math.sqrt(baseRed * baseRed + baseGreen * baseGreen + baseBlue * baseBlue);\n        return value < COLOR_THRESHOLD;\n\n    }\n\n    //获取标题颜色\n    private int getNotificationColorInternal(Context context) {\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);\n        builder.setContentTitle(DUMMY_TITLE);\n        Notification notification = builder.build();\n\n        ViewGroup notificationRoot = (ViewGroup) notification.contentView.apply(context, new FrameLayout(context));\n        TextView title = (TextView) notificationRoot.findViewById(android.R.id.title);\n        if (title == null) { //如果ROM厂商更改了默认的id\n            iteratorView(notificationRoot, new Filter() {\n                @Override\n                public void filter(View view) {\n                    if (view instanceof TextView) {\n                        TextView textView = (TextView) view;\n                        if (DUMMY_TITLE.equals(textView.getText().toString())) {\n\n                            titleColor = textView.getCurrentTextColor();\n                        }\n                    }\n                }\n            });\n            return titleColor;\n        } else {\n\n            return title.getCurrentTextColor();\n        }\n    }\n\n\n    private int getNotificationColorCompat(Context context) {\n        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);\n        Notification notification = builder.build();\n        int layoutId = notification.contentView.getLayoutId();\n        ViewGroup notificationRoot = (ViewGroup) LayoutInflater.from(context).inflate(layoutId, null);\n        TextView title = (TextView) notificationRoot.findViewById(android.R.id.title);\n        if (title == null) {\n            final List<TextView> textViews = new ArrayList<>();\n            iteratorView(notificationRoot, new Filter() {\n                @Override\n                public void filter(View view) {\n                    if (view instanceof TextView) {\n                        textViews.add((TextView) view);\n                    }\n                }\n            });\n            float minTextSize = Integer.MIN_VALUE;\n            int index = 0;\n            for (int i = 0, j = textViews.size(); i < j; i++) {\n                float currentSize = textViews.get(i).getTextSize();\n                if (currentSize > minTextSize) {\n                    minTextSize = currentSize;\n                    index = i;\n                }\n            }\n            textViews.get(index).setText(DUMMY_TITLE);\n            return textViews.get(index).getCurrentTextColor();\n        } else {\n            return title.getCurrentTextColor();\n        }\n\n    }\n\n\n    private void iteratorView(View view, Filter filter) {\n        if (view == null || filter == null) {\n            return;\n        }\n        filter.filter(view);\n        if (view instanceof ViewGroup) {\n            ViewGroup container = (ViewGroup) view;\n            for (int i = 0, j = container.getChildCount(); i < j; i++) {\n                View child = container.getChildAt(i);\n                iteratorView(child, filter);\n            }\n        }\n\n    }\n\n    interface Filter {\n        void filter(View view);\n    }\n\n}\n```\n\n参考文章： http://www.jianshu.com/p/426d85f34561","slug":"消息栏通知Notification的那些事儿","published":1,"updated":"2016-12-01T01:34:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovduz000hbqc656jgyu0o","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>最近在开发过程中，用到了Notification的功能，需要实现一个自定义的布局。实现方式相信大家也都知道，就是通过RemoteViews来实现。但是在开发过程中还是遇到不少问题。<br><a id=\"more\"></a><br>首先，还是有必要说明一下，<strong>RemoteViews</strong>主要被用于AppWidget和Notification，它描述一个在其它进程中显示的View。</p>\n<h4 id=\"RemoteViews-使用过程中遇到的问题\"><a href=\"#RemoteViews-使用过程中遇到的问题\" class=\"headerlink\" title=\"RemoteViews 使用过程中遇到的问题\"></a>RemoteViews 使用过程中遇到的问题</h4><blockquote>\n<p>首先是关于 RemoteViews 设置的问题</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Notification notification = new NotificationCompat.Builder(this)</div><div class=\"line\">                .setContent(remoteViews)</div><div class=\"line\">                .setSmallIcon(R.mipmap.ic_launcher)</div><div class=\"line\">                .setTicker(&quot;您有新短消息，请注意查收！&quot;).build();</div></pre></td></tr></table></figure>\n<p>NotificationCompat.Builder是有提供setContent的方法来设置RemoteViews的。然而存在一个问题，通过setContent()方法获得的Notification是固定高度的。如果View的高度比默认高度要大的话，就会有一部分显示不出来。</p>\n<p>那么如何设置能够不存在高度限定呢？ 实际上也简单。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(android.os.Build.VERSION.SDK_INT &gt;= 16) &#123;</div><div class=\"line\">            notification.bigContentView = remoteViews;</div><div class=\"line\">        &#125;</div><div class=\"line\"> notification.contentView = remoteViews;</div></pre></td></tr></table></figure></p>\n<p>android 在sdk16的时候引入了通知的展开和收起的功能，通过两个手指滑动操作，这里 bigContentView 表示展开时的显示的View，而contentView 表示收起时显示的View。我们可以通过设置 bigContentView 来完全显示，但仍然需要注意几个点：</p>\n<ul>\n<li><p>bigContentView是在sdk16的时候才引入的，所以一定不要忘记判断一下。对于小于16，的则只能定高了。</p>\n</li>\n<li><p>就算是bigContentView 也是有最大高度的，其最大高度是256dp，而contentView 默认情况下高度为64p。</p>\n</li>\n<li><p>Notification 使用过程中， .setSmallIcon、setTicker 是一定要设置的。</p>\n</li>\n</ul>\n<blockquote>\n<p>自定义View 对背景色的适配</p>\n</blockquote>\n<p>Android通知栏的背景各式各样，不同的ROM都适配有不同的背景。不同的Android版本通知栏背景也不一样，一旦我们为自定义通知上的元素设置了特定背景或颜色，就肯定会带来兼容性问题。</p>\n<p>由此可以想到一种方法，将背景设为透明的，然后如果可以找到系统通知栏默认的文字样式，这样就可以显示出同样的效果了。</p>\n<p><img src=\"/imgs/notification_03.png\" alt=\"屏幕快照 2016-11-13 13.01.56.png\"></p>\n<p>android 也确实提供了这样的样式，使用方式也简单,如下面这样设置即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">android:textAppearance=&quot;@style/TextAppearance.StatusBar.EventContent.Title&quot;</div></pre></td></tr></table></figure></p>\n<p>同时还提供了其他样式，如 TextAppearance.StatusBar.EventContent.Time，TextAppearance.StatusBar.EventContent.Info 等都可以试试。</p>\n<p>然而这并没有结束，5.0以后的版本，android 又修改了新的默认的样式，所以就需要我们新建layout-v21，添加新的适配文件。</p>\n<p><img src=\"/imgs/notification_04.png\" alt=\"屏幕快照 2016-11-13 13.27.23.png\"></p>\n<p>设置的方式并没有什么不同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">android:textAppearance=&quot;@android:style/TextAppearance.Material.Notification.Title&quot;</div></pre></td></tr></table></figure></p>\n<p>ok ，大功告成，来看一下效果。</p>\n<p>白色背景：<br><img src=\"/imgs/notification_01.png\" alt=\"截屏_20161113_133535.png\"></p>\n<p>黑色背景：</p>\n<p><img src=\"/imgs/notification_02.png\" alt=\"Screenshot_20161113-134026.png\"></p>\n<p>下面介绍一种大神的方案-大体的方式是： 通过获取系统通知栏Notification默认的标题颜色，然后比对色值，判断出通知栏背景的颜色是黑色域还是白色域，之后就可以选取相应的自定义通知栏。</p>\n<p>对这个方案也测试了一下，vivo测试机 通知栏背景色是白色的，然而获得的标题的颜色也是白色的，也就是说 还是会出现 不可预知的问题。总之，学习一下还是可以的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div></pre></td><td class=\"code\"><pre><div class=\"line\">//逻辑相应代码</div><div class=\"line\">public class NoficationBar &#123;</div><div class=\"line\"></div><div class=\"line\">    private static final double COLOR_THRESHOLD = 180.0;</div><div class=\"line\"></div><div class=\"line\">    private String DUMMY_TITLE = &quot;DUMMY_TITLE&quot;;</div><div class=\"line\">    private int titleColor;</div><div class=\"line\"></div><div class=\"line\">    public NoficationBar() &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //判断是否Notification背景是否为黑色</div><div class=\"line\">    public boolean isDarkNotificationBar(Context context) &#123;</div><div class=\"line\">        return !isColorSimilar(Color.BLACK, getNotificationTitleColor(context));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    //获取Notification 标题的颜色</div><div class=\"line\">    private int getNotificationTitleColor(Context context) &#123;</div><div class=\"line\">        int color = 0;</div><div class=\"line\">        if (context instanceof AppCompatActivity) &#123;</div><div class=\"line\">             color = getNotificationColorCompat(context);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            color = getNotificationColorInternal(context);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return color;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //判断颜色是否相似</div><div class=\"line\">    public boolean isColorSimilar(int baseColor, int color) &#123;</div><div class=\"line\">        int simpleBaseColor = baseColor | 0xff000000;</div><div class=\"line\">        int simpleColor = color | 0xff000000;</div><div class=\"line\">        int baseRed = Color.red(simpleBaseColor) - Color.red(simpleColor);</div><div class=\"line\">        int baseGreen = Color.green(simpleBaseColor) - Color.green(simpleColor);</div><div class=\"line\">        int baseBlue = Color.blue(simpleBaseColor) - Color.blue(simpleColor);</div><div class=\"line\"></div><div class=\"line\">        double value = Math.sqrt(baseRed * baseRed + baseGreen * baseGreen + baseBlue * baseBlue);</div><div class=\"line\">        return value &lt; COLOR_THRESHOLD;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //获取标题颜色</div><div class=\"line\">    private int getNotificationColorInternal(Context context) &#123;</div><div class=\"line\">        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);</div><div class=\"line\">        builder.setContentTitle(DUMMY_TITLE);</div><div class=\"line\">        Notification notification = builder.build();</div><div class=\"line\"></div><div class=\"line\">        ViewGroup notificationRoot = (ViewGroup) notification.contentView.apply(context, new FrameLayout(context));</div><div class=\"line\">        TextView title = (TextView) notificationRoot.findViewById(android.R.id.title);</div><div class=\"line\">        if (title == null) &#123; //如果ROM厂商更改了默认的id</div><div class=\"line\">            iteratorView(notificationRoot, new Filter() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void filter(View view) &#123;</div><div class=\"line\">                    if (view instanceof TextView) &#123;</div><div class=\"line\">                        TextView textView = (TextView) view;</div><div class=\"line\">                        if (DUMMY_TITLE.equals(textView.getText().toString())) &#123;</div><div class=\"line\"></div><div class=\"line\">                            titleColor = textView.getCurrentTextColor();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">            return titleColor;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\"></div><div class=\"line\">            return title.getCurrentTextColor();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    private int getNotificationColorCompat(Context context) &#123;</div><div class=\"line\">        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);</div><div class=\"line\">        Notification notification = builder.build();</div><div class=\"line\">        int layoutId = notification.contentView.getLayoutId();</div><div class=\"line\">        ViewGroup notificationRoot = (ViewGroup) LayoutInflater.from(context).inflate(layoutId, null);</div><div class=\"line\">        TextView title = (TextView) notificationRoot.findViewById(android.R.id.title);</div><div class=\"line\">        if (title == null) &#123;</div><div class=\"line\">            final List&lt;TextView&gt; textViews = new ArrayList&lt;&gt;();</div><div class=\"line\">            iteratorView(notificationRoot, new Filter() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void filter(View view) &#123;</div><div class=\"line\">                    if (view instanceof TextView) &#123;</div><div class=\"line\">                        textViews.add((TextView) view);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">            float minTextSize = Integer.MIN_VALUE;</div><div class=\"line\">            int index = 0;</div><div class=\"line\">            for (int i = 0, j = textViews.size(); i &lt; j; i++) &#123;</div><div class=\"line\">                float currentSize = textViews.get(i).getTextSize();</div><div class=\"line\">                if (currentSize &gt; minTextSize) &#123;</div><div class=\"line\">                    minTextSize = currentSize;</div><div class=\"line\">                    index = i;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            textViews.get(index).setText(DUMMY_TITLE);</div><div class=\"line\">            return textViews.get(index).getCurrentTextColor();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return title.getCurrentTextColor();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    private void iteratorView(View view, Filter filter) &#123;</div><div class=\"line\">        if (view == null || filter == null) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        filter.filter(view);</div><div class=\"line\">        if (view instanceof ViewGroup) &#123;</div><div class=\"line\">            ViewGroup container = (ViewGroup) view;</div><div class=\"line\">            for (int i = 0, j = container.getChildCount(); i &lt; j; i++) &#123;</div><div class=\"line\">                View child = container.getChildAt(i);</div><div class=\"line\">                iteratorView(child, filter);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    interface Filter &#123;</div><div class=\"line\">        void filter(View view);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>参考文章： <a href=\"http://www.jianshu.com/p/426d85f34561\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/426d85f34561</a></p>\n","excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>最近在开发过程中，用到了Notification的功能，需要实现一个自定义的布局。实现方式相信大家也都知道，就是通过RemoteViews来实现。但是在开发过程中还是遇到不少问题。<br>","more":"<br>首先，还是有必要说明一下，<strong>RemoteViews</strong>主要被用于AppWidget和Notification，它描述一个在其它进程中显示的View。</p>\n<h4 id=\"RemoteViews-使用过程中遇到的问题\"><a href=\"#RemoteViews-使用过程中遇到的问题\" class=\"headerlink\" title=\"RemoteViews 使用过程中遇到的问题\"></a>RemoteViews 使用过程中遇到的问题</h4><blockquote>\n<p>首先是关于 RemoteViews 设置的问题</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Notification notification = new NotificationCompat.Builder(this)</div><div class=\"line\">                .setContent(remoteViews)</div><div class=\"line\">                .setSmallIcon(R.mipmap.ic_launcher)</div><div class=\"line\">                .setTicker(&quot;您有新短消息，请注意查收！&quot;).build();</div></pre></td></tr></table></figure>\n<p>NotificationCompat.Builder是有提供setContent的方法来设置RemoteViews的。然而存在一个问题，通过setContent()方法获得的Notification是固定高度的。如果View的高度比默认高度要大的话，就会有一部分显示不出来。</p>\n<p>那么如何设置能够不存在高度限定呢？ 实际上也简单。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(android.os.Build.VERSION.SDK_INT &gt;= 16) &#123;</div><div class=\"line\">            notification.bigContentView = remoteViews;</div><div class=\"line\">        &#125;</div><div class=\"line\"> notification.contentView = remoteViews;</div></pre></td></tr></table></figure></p>\n<p>android 在sdk16的时候引入了通知的展开和收起的功能，通过两个手指滑动操作，这里 bigContentView 表示展开时的显示的View，而contentView 表示收起时显示的View。我们可以通过设置 bigContentView 来完全显示，但仍然需要注意几个点：</p>\n<ul>\n<li><p>bigContentView是在sdk16的时候才引入的，所以一定不要忘记判断一下。对于小于16，的则只能定高了。</p>\n</li>\n<li><p>就算是bigContentView 也是有最大高度的，其最大高度是256dp，而contentView 默认情况下高度为64p。</p>\n</li>\n<li><p>Notification 使用过程中， .setSmallIcon、setTicker 是一定要设置的。</p>\n</li>\n</ul>\n<blockquote>\n<p>自定义View 对背景色的适配</p>\n</blockquote>\n<p>Android通知栏的背景各式各样，不同的ROM都适配有不同的背景。不同的Android版本通知栏背景也不一样，一旦我们为自定义通知上的元素设置了特定背景或颜色，就肯定会带来兼容性问题。</p>\n<p>由此可以想到一种方法，将背景设为透明的，然后如果可以找到系统通知栏默认的文字样式，这样就可以显示出同样的效果了。</p>\n<p><img src=\"/imgs/notification_03.png\" alt=\"屏幕快照 2016-11-13 13.01.56.png\"></p>\n<p>android 也确实提供了这样的样式，使用方式也简单,如下面这样设置即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">android:textAppearance=&quot;@style/TextAppearance.StatusBar.EventContent.Title&quot;</div></pre></td></tr></table></figure></p>\n<p>同时还提供了其他样式，如 TextAppearance.StatusBar.EventContent.Time，TextAppearance.StatusBar.EventContent.Info 等都可以试试。</p>\n<p>然而这并没有结束，5.0以后的版本，android 又修改了新的默认的样式，所以就需要我们新建layout-v21，添加新的适配文件。</p>\n<p><img src=\"/imgs/notification_04.png\" alt=\"屏幕快照 2016-11-13 13.27.23.png\"></p>\n<p>设置的方式并没有什么不同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">android:textAppearance=&quot;@android:style/TextAppearance.Material.Notification.Title&quot;</div></pre></td></tr></table></figure></p>\n<p>ok ，大功告成，来看一下效果。</p>\n<p>白色背景：<br><img src=\"/imgs/notification_01.png\" alt=\"截屏_20161113_133535.png\"></p>\n<p>黑色背景：</p>\n<p><img src=\"/imgs/notification_02.png\" alt=\"Screenshot_20161113-134026.png\"></p>\n<p>下面介绍一种大神的方案-大体的方式是： 通过获取系统通知栏Notification默认的标题颜色，然后比对色值，判断出通知栏背景的颜色是黑色域还是白色域，之后就可以选取相应的自定义通知栏。</p>\n<p>对这个方案也测试了一下，vivo测试机 通知栏背景色是白色的，然而获得的标题的颜色也是白色的，也就是说 还是会出现 不可预知的问题。总之，学习一下还是可以的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div></pre></td><td class=\"code\"><pre><div class=\"line\">//逻辑相应代码</div><div class=\"line\">public class NoficationBar &#123;</div><div class=\"line\"></div><div class=\"line\">    private static final double COLOR_THRESHOLD = 180.0;</div><div class=\"line\"></div><div class=\"line\">    private String DUMMY_TITLE = &quot;DUMMY_TITLE&quot;;</div><div class=\"line\">    private int titleColor;</div><div class=\"line\"></div><div class=\"line\">    public NoficationBar() &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //判断是否Notification背景是否为黑色</div><div class=\"line\">    public boolean isDarkNotificationBar(Context context) &#123;</div><div class=\"line\">        return !isColorSimilar(Color.BLACK, getNotificationTitleColor(context));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    //获取Notification 标题的颜色</div><div class=\"line\">    private int getNotificationTitleColor(Context context) &#123;</div><div class=\"line\">        int color = 0;</div><div class=\"line\">        if (context instanceof AppCompatActivity) &#123;</div><div class=\"line\">             color = getNotificationColorCompat(context);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            color = getNotificationColorInternal(context);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return color;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //判断颜色是否相似</div><div class=\"line\">    public boolean isColorSimilar(int baseColor, int color) &#123;</div><div class=\"line\">        int simpleBaseColor = baseColor | 0xff000000;</div><div class=\"line\">        int simpleColor = color | 0xff000000;</div><div class=\"line\">        int baseRed = Color.red(simpleBaseColor) - Color.red(simpleColor);</div><div class=\"line\">        int baseGreen = Color.green(simpleBaseColor) - Color.green(simpleColor);</div><div class=\"line\">        int baseBlue = Color.blue(simpleBaseColor) - Color.blue(simpleColor);</div><div class=\"line\"></div><div class=\"line\">        double value = Math.sqrt(baseRed * baseRed + baseGreen * baseGreen + baseBlue * baseBlue);</div><div class=\"line\">        return value &lt; COLOR_THRESHOLD;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //获取标题颜色</div><div class=\"line\">    private int getNotificationColorInternal(Context context) &#123;</div><div class=\"line\">        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);</div><div class=\"line\">        builder.setContentTitle(DUMMY_TITLE);</div><div class=\"line\">        Notification notification = builder.build();</div><div class=\"line\"></div><div class=\"line\">        ViewGroup notificationRoot = (ViewGroup) notification.contentView.apply(context, new FrameLayout(context));</div><div class=\"line\">        TextView title = (TextView) notificationRoot.findViewById(android.R.id.title);</div><div class=\"line\">        if (title == null) &#123; //如果ROM厂商更改了默认的id</div><div class=\"line\">            iteratorView(notificationRoot, new Filter() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void filter(View view) &#123;</div><div class=\"line\">                    if (view instanceof TextView) &#123;</div><div class=\"line\">                        TextView textView = (TextView) view;</div><div class=\"line\">                        if (DUMMY_TITLE.equals(textView.getText().toString())) &#123;</div><div class=\"line\"></div><div class=\"line\">                            titleColor = textView.getCurrentTextColor();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">            return titleColor;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\"></div><div class=\"line\">            return title.getCurrentTextColor();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    private int getNotificationColorCompat(Context context) &#123;</div><div class=\"line\">        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);</div><div class=\"line\">        Notification notification = builder.build();</div><div class=\"line\">        int layoutId = notification.contentView.getLayoutId();</div><div class=\"line\">        ViewGroup notificationRoot = (ViewGroup) LayoutInflater.from(context).inflate(layoutId, null);</div><div class=\"line\">        TextView title = (TextView) notificationRoot.findViewById(android.R.id.title);</div><div class=\"line\">        if (title == null) &#123;</div><div class=\"line\">            final List&lt;TextView&gt; textViews = new ArrayList&lt;&gt;();</div><div class=\"line\">            iteratorView(notificationRoot, new Filter() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void filter(View view) &#123;</div><div class=\"line\">                    if (view instanceof TextView) &#123;</div><div class=\"line\">                        textViews.add((TextView) view);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">            float minTextSize = Integer.MIN_VALUE;</div><div class=\"line\">            int index = 0;</div><div class=\"line\">            for (int i = 0, j = textViews.size(); i &lt; j; i++) &#123;</div><div class=\"line\">                float currentSize = textViews.get(i).getTextSize();</div><div class=\"line\">                if (currentSize &gt; minTextSize) &#123;</div><div class=\"line\">                    minTextSize = currentSize;</div><div class=\"line\">                    index = i;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            textViews.get(index).setText(DUMMY_TITLE);</div><div class=\"line\">            return textViews.get(index).getCurrentTextColor();</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return title.getCurrentTextColor();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    private void iteratorView(View view, Filter filter) &#123;</div><div class=\"line\">        if (view == null || filter == null) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        filter.filter(view);</div><div class=\"line\">        if (view instanceof ViewGroup) &#123;</div><div class=\"line\">            ViewGroup container = (ViewGroup) view;</div><div class=\"line\">            for (int i = 0, j = container.getChildCount(); i &lt; j; i++) &#123;</div><div class=\"line\">                View child = container.getChildAt(i);</div><div class=\"line\">                iteratorView(child, filter);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    interface Filter &#123;</div><div class=\"line\">        void filter(View view);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>参考文章： <a href=\"http://www.jianshu.com/p/426d85f34561\">http://www.jianshu.com/p/426d85f34561</a></p>"},{"title":"Rxjava学习：谈谈Rxjava的使用","date":"2016-08-25T09:27:24.000Z","_content":"![配图](/imgs/8c91ad2096d7aaea9dc52dc4c86a8d58.jpg)\n\n### 前言\n\n在 [Rxjava学习:初识Rxjava](http://www.jianshu.com/p/264a1322669a) 一文中，我们对Rxjava的几个基本概念做了介绍，今天就来谈谈对Rxjava的使用。\n<!-- more-->\n### Rxjava的具体使用\n下面还是从几个基本概念开始入手：\n#### 创建Observer\n作为Rxjava处理数据的最终出口，首先我们需要对其进行实现。\n\n```\nObserver<String> observer = new Observer<String>() {\n    @Override\n    public void onNext(String s) {\n        Log.d(tag, \"Item: \" + s);\n    }\n\n    @Override\n    public void onCompleted() {\n        Log.d(tag, \"Completed!\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.d(tag, \"Error!\");\n    }\n};\n```\n除了 Observer 接口之外，RxJava 还提供了一个实现了 Observer 的抽象类：Subscriber。实际上在Observer接口的使用过程中，也是将其转换成Subscriber 来使用。\n 下面我们来看一下订阅方法的源码实现：\n```\npublic final Subscription subscribe(final Observer<? super T> observer) {\n    if (observer instanceof Subscriber) {\n        return subscribe((Subscriber<? super T>)observer);\n    }\n    if (observer == null) {\n        throw new NullPointerException(\"observer is null\");\n    }\n    return subscribe(new ObserverSubscriber<T>(observer));\n}\n```\n可以看到 如果是 **Subscriber** 将直接被使用，如果是**observer**将被转换为 **ObserverSubscriber** 来使用。这里提到了** ObserverSubscriber **类 我们再来看一下 其源码，就会很清晰的理解这个过程了：\n```\npublic final class ObserverSubscriber<T> extends Subscriber<T> {\n    final Observer<? super T> observer;\n    public ObserverSubscriber(Observer<? super T> observer) {\n        this.observer = observer;\n    }\n        @Override\n    public void onNext(T t) {\n        observer.onNext(t);\n    }\n        @Override\n    public void onError(Throwable e) {\n        observer.onError(e);\n    }\n        @Override\n    public void onCompleted() {\n        observer.onCompleted();\n    }\n}\n```\n\n当然Subscriber 对 Observer 接口也进行了一些扩展。 下面提一下 Subscriber 与 Observer 使用上的不同：\n- onStart(): Subscriber 对外提供了onStart 方法用于实现，onStart 在Subscriber中是一个空方法，用户可以选择性实现。**会在整个订阅过程开始之前被调用，与Subscribe()方法发生在同一线程，可以做一些 比如：数据的初始化 之类的操作，但不适合做对线程有具体要求的工作。例如：初始化UI界面，必须发生在主线程。**\n\n- unsubscribe(): Subscriber 同时实现了另一个接口 Subscription ，Subscription 接口只提供了两个方法：\n  ```\n  public interface Subscription {\n          void unsubscribe();\n          boolean isUnsubscribed();\n  }\n  ```\nSubscriber 对这两个方法分别做了实现，isUnsubscribed() 用于判断Subscriber 是否已经订阅 ，而 unsubscribe() 方法用于 取消订阅。在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。\n\n#### 创建 Observable\nObservable 提供了大量的方法来进行 数据变换，下面我们借用 [Rxjava学习:初识Rxjava](http://www.jianshu.com/p/264a1322669a) 一文中的例子来对其各个API进行理解：\n```\nObservable.from(folders)\n    .flatMap(new Func1<File, Observable<File>>() {\n        @Override\n        public Observable<File> call(File file) {\n            return Observable.from(file.listFiles());\n        }\n    })\n    .filter(new Func1<File, Boolean>() {\n        @Override\n        public Boolean call(File file) {\n            return file.getName().endsWith(\".png\");\n        }\n    })\n    .map(new Func1<File, Bitmap>() {\n        @Override\n        public Bitmap call(File file) {\n            return getBitmapFromFile(file);\n        }\n    })\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Action1<Bitmap>() {\n        @Override\n        public void call(Bitmap bitmap) {\n            imageCollectorView.addImage(bitmap);\n        }\n    });\n```\n- flatMap() : 通过传入的对象，根据需求 ，创建新的Observable 对象，并代替现有的Observable对象完成剩下的所要执行的方法。\n\n- map() : 将传入的对象转换成另一个对象,是可以被直接发送到了Subscriber 的回调方法中使用的。如同上面示例中那样。\n\n- filter() : 过滤筛选。 通过事件方法进行筛选，将符合要求的数据传递到下一个事件。例如示例中：符合**file.getName().endsWith(\".png”)** 要求的数据才会传递。\n\n#### 调用 subscribe() 进行订阅\n创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：\n```\nobservable.subscribe(observer);\n```\n同时subscribe()方法也提供了其他的重载以实现不完整定义的回调。\n```\n// 自动创建 Subscriber ，并使用 onNext 来定义 onNext()\nsubscribe(final Action1<? super T> onNext) \n// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()\nsubscribe(final Action1<? super T> onNext, final Action1<Throwable> onError) \n// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()\nsubscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onCompleted)\n```\n\n### 总结：\n\n 讲到现在，对Rxjava的使用也有了清晰的了解，在这里并没有提到Scheduler的使用，我觉得Scheduler  对于Rxjava是十分重要的一部分，我打算在下一篇中做详细的介绍，并对Observable其他重要的API方法进行介绍。","source":"_posts/Rxjava学习：谈谈Rxjava的使用.md","raw":"---\ntitle: Rxjava学习：谈谈Rxjava的使用\ndate: 2016-08-25 17:27:24\ncategories: Rxjava学习\ntags:\n---\n![配图](/imgs/8c91ad2096d7aaea9dc52dc4c86a8d58.jpg)\n\n### 前言\n\n在 [Rxjava学习:初识Rxjava](http://www.jianshu.com/p/264a1322669a) 一文中，我们对Rxjava的几个基本概念做了介绍，今天就来谈谈对Rxjava的使用。\n<!-- more-->\n### Rxjava的具体使用\n下面还是从几个基本概念开始入手：\n#### 创建Observer\n作为Rxjava处理数据的最终出口，首先我们需要对其进行实现。\n\n```\nObserver<String> observer = new Observer<String>() {\n    @Override\n    public void onNext(String s) {\n        Log.d(tag, \"Item: \" + s);\n    }\n\n    @Override\n    public void onCompleted() {\n        Log.d(tag, \"Completed!\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.d(tag, \"Error!\");\n    }\n};\n```\n除了 Observer 接口之外，RxJava 还提供了一个实现了 Observer 的抽象类：Subscriber。实际上在Observer接口的使用过程中，也是将其转换成Subscriber 来使用。\n 下面我们来看一下订阅方法的源码实现：\n```\npublic final Subscription subscribe(final Observer<? super T> observer) {\n    if (observer instanceof Subscriber) {\n        return subscribe((Subscriber<? super T>)observer);\n    }\n    if (observer == null) {\n        throw new NullPointerException(\"observer is null\");\n    }\n    return subscribe(new ObserverSubscriber<T>(observer));\n}\n```\n可以看到 如果是 **Subscriber** 将直接被使用，如果是**observer**将被转换为 **ObserverSubscriber** 来使用。这里提到了** ObserverSubscriber **类 我们再来看一下 其源码，就会很清晰的理解这个过程了：\n```\npublic final class ObserverSubscriber<T> extends Subscriber<T> {\n    final Observer<? super T> observer;\n    public ObserverSubscriber(Observer<? super T> observer) {\n        this.observer = observer;\n    }\n        @Override\n    public void onNext(T t) {\n        observer.onNext(t);\n    }\n        @Override\n    public void onError(Throwable e) {\n        observer.onError(e);\n    }\n        @Override\n    public void onCompleted() {\n        observer.onCompleted();\n    }\n}\n```\n\n当然Subscriber 对 Observer 接口也进行了一些扩展。 下面提一下 Subscriber 与 Observer 使用上的不同：\n- onStart(): Subscriber 对外提供了onStart 方法用于实现，onStart 在Subscriber中是一个空方法，用户可以选择性实现。**会在整个订阅过程开始之前被调用，与Subscribe()方法发生在同一线程，可以做一些 比如：数据的初始化 之类的操作，但不适合做对线程有具体要求的工作。例如：初始化UI界面，必须发生在主线程。**\n\n- unsubscribe(): Subscriber 同时实现了另一个接口 Subscription ，Subscription 接口只提供了两个方法：\n  ```\n  public interface Subscription {\n          void unsubscribe();\n          boolean isUnsubscribed();\n  }\n  ```\nSubscriber 对这两个方法分别做了实现，isUnsubscribed() 用于判断Subscriber 是否已经订阅 ，而 unsubscribe() 方法用于 取消订阅。在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。\n\n#### 创建 Observable\nObservable 提供了大量的方法来进行 数据变换，下面我们借用 [Rxjava学习:初识Rxjava](http://www.jianshu.com/p/264a1322669a) 一文中的例子来对其各个API进行理解：\n```\nObservable.from(folders)\n    .flatMap(new Func1<File, Observable<File>>() {\n        @Override\n        public Observable<File> call(File file) {\n            return Observable.from(file.listFiles());\n        }\n    })\n    .filter(new Func1<File, Boolean>() {\n        @Override\n        public Boolean call(File file) {\n            return file.getName().endsWith(\".png\");\n        }\n    })\n    .map(new Func1<File, Bitmap>() {\n        @Override\n        public Bitmap call(File file) {\n            return getBitmapFromFile(file);\n        }\n    })\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Action1<Bitmap>() {\n        @Override\n        public void call(Bitmap bitmap) {\n            imageCollectorView.addImage(bitmap);\n        }\n    });\n```\n- flatMap() : 通过传入的对象，根据需求 ，创建新的Observable 对象，并代替现有的Observable对象完成剩下的所要执行的方法。\n\n- map() : 将传入的对象转换成另一个对象,是可以被直接发送到了Subscriber 的回调方法中使用的。如同上面示例中那样。\n\n- filter() : 过滤筛选。 通过事件方法进行筛选，将符合要求的数据传递到下一个事件。例如示例中：符合**file.getName().endsWith(\".png”)** 要求的数据才会传递。\n\n#### 调用 subscribe() 进行订阅\n创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：\n```\nobservable.subscribe(observer);\n```\n同时subscribe()方法也提供了其他的重载以实现不完整定义的回调。\n```\n// 自动创建 Subscriber ，并使用 onNext 来定义 onNext()\nsubscribe(final Action1<? super T> onNext) \n// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()\nsubscribe(final Action1<? super T> onNext, final Action1<Throwable> onError) \n// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()\nsubscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onCompleted)\n```\n\n### 总结：\n\n 讲到现在，对Rxjava的使用也有了清晰的了解，在这里并没有提到Scheduler的使用，我觉得Scheduler  对于Rxjava是十分重要的一部分，我打算在下一篇中做详细的介绍，并对Observable其他重要的API方法进行介绍。","slug":"Rxjava学习：谈谈Rxjava的使用","published":1,"updated":"2016-09-02T08:57:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovdv1000lbqc6i7pl7ygq","content":"<p><img src=\"/imgs/8c91ad2096d7aaea9dc52dc4c86a8d58.jpg\" alt=\"配图\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在 <a href=\"http://www.jianshu.com/p/264a1322669a\" target=\"_blank\" rel=\"external\">Rxjava学习:初识Rxjava</a> 一文中，我们对Rxjava的几个基本概念做了介绍，今天就来谈谈对Rxjava的使用。<br><a id=\"more\"></a></p>\n<h3 id=\"Rxjava的具体使用\"><a href=\"#Rxjava的具体使用\" class=\"headerlink\" title=\"Rxjava的具体使用\"></a>Rxjava的具体使用</h3><p>下面还是从几个基本概念开始入手：</p>\n<h4 id=\"创建Observer\"><a href=\"#创建Observer\" class=\"headerlink\" title=\"创建Observer\"></a>创建Observer</h4><p>作为Rxjava处理数据的最终出口，首先我们需要对其进行实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onNext(String s) &#123;</div><div class=\"line\">        Log.d(tag, &quot;Item: &quot; + s);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onCompleted() &#123;</div><div class=\"line\">        Log.d(tag, &quot;Completed!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onError(Throwable e) &#123;</div><div class=\"line\">        Log.d(tag, &quot;Error!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>除了 Observer 接口之外，RxJava 还提供了一个实现了 Observer 的抽象类：Subscriber。实际上在Observer接口的使用过程中，也是将其转换成Subscriber 来使用。<br> 下面我们来看一下订阅方法的源码实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final Subscription subscribe(final Observer&lt;? super T&gt; observer) &#123;</div><div class=\"line\">    if (observer instanceof Subscriber) &#123;</div><div class=\"line\">        return subscribe((Subscriber&lt;? super T&gt;)observer);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (observer == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;observer is null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return subscribe(new ObserverSubscriber&lt;T&gt;(observer));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到 如果是 <strong>Subscriber</strong> 将直接被使用，如果是<strong>observer</strong>将被转换为 <strong>ObserverSubscriber</strong> 来使用。这里提到了<strong> ObserverSubscriber </strong>类 我们再来看一下 其源码，就会很清晰的理解这个过程了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final class ObserverSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; &#123;</div><div class=\"line\">    final Observer&lt;? super T&gt; observer;</div><div class=\"line\">    public ObserverSubscriber(Observer&lt;? super T&gt; observer) &#123;</div><div class=\"line\">        this.observer = observer;</div><div class=\"line\">    &#125;</div><div class=\"line\">        @Override</div><div class=\"line\">    public void onNext(T t) &#123;</div><div class=\"line\">        observer.onNext(t);</div><div class=\"line\">    &#125;</div><div class=\"line\">        @Override</div><div class=\"line\">    public void onError(Throwable e) &#123;</div><div class=\"line\">        observer.onError(e);</div><div class=\"line\">    &#125;</div><div class=\"line\">        @Override</div><div class=\"line\">    public void onCompleted() &#123;</div><div class=\"line\">        observer.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当然Subscriber 对 Observer 接口也进行了一些扩展。 下面提一下 Subscriber 与 Observer 使用上的不同：</p>\n<ul>\n<li><p>onStart(): Subscriber 对外提供了onStart 方法用于实现，onStart 在Subscriber中是一个空方法，用户可以选择性实现。<strong>会在整个订阅过程开始之前被调用，与Subscribe()方法发生在同一线程，可以做一些 比如：数据的初始化 之类的操作，但不适合做对线程有具体要求的工作。例如：初始化UI界面，必须发生在主线程。</strong></p>\n</li>\n<li><p>unsubscribe(): Subscriber 同时实现了另一个接口 Subscription ，Subscription 接口只提供了两个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Subscription &#123;</div><div class=\"line\">        void unsubscribe();</div><div class=\"line\">        boolean isUnsubscribed();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Subscriber 对这两个方法分别做了实现，isUnsubscribed() 用于判断Subscriber 是否已经订阅 ，而 unsubscribe() 方法用于 取消订阅。在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</p>\n<h4 id=\"创建-Observable\"><a href=\"#创建-Observable\" class=\"headerlink\" title=\"创建 Observable\"></a>创建 Observable</h4><p>Observable 提供了大量的方法来进行 数据变换，下面我们借用 <a href=\"http://www.jianshu.com/p/264a1322669a\" target=\"_blank\" rel=\"external\">Rxjava学习:初识Rxjava</a> 一文中的例子来对其各个API进行理解：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(folders)</div><div class=\"line\">    .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Observable&lt;File&gt; call(File file) &#123;</div><div class=\"line\">            return Observable.from(file.listFiles());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .filter(new Func1&lt;File, Boolean&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Boolean call(File file) &#123;</div><div class=\"line\">            return file.getName().endsWith(&quot;.png&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .map(new Func1&lt;File, Bitmap&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Bitmap call(File file) &#123;</div><div class=\"line\">            return getBitmapFromFile(file);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">    .subscribe(new Action1&lt;Bitmap&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void call(Bitmap bitmap) &#123;</div><div class=\"line\">            imageCollectorView.addImage(bitmap);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>flatMap() : 通过传入的对象，根据需求 ，创建新的Observable 对象，并代替现有的Observable对象完成剩下的所要执行的方法。</p>\n</li>\n<li><p>map() : 将传入的对象转换成另一个对象,是可以被直接发送到了Subscriber 的回调方法中使用的。如同上面示例中那样。</p>\n</li>\n<li><p>filter() : 过滤筛选。 通过事件方法进行筛选，将符合要求的数据传递到下一个事件。例如示例中：符合<strong>file.getName().endsWith(“.png”)</strong> 要求的数据才会传递。</p>\n</li>\n</ul>\n<h4 id=\"调用-subscribe-进行订阅\"><a href=\"#调用-subscribe-进行订阅\" class=\"headerlink\" title=\"调用 subscribe() 进行订阅\"></a>调用 subscribe() 进行订阅</h4><p>创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">observable.subscribe(observer);</div></pre></td></tr></table></figure></p>\n<p>同时subscribe()方法也提供了其他的重载以实现不完整定义的回调。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 自动创建 Subscriber ，并使用 onNext 来定义 onNext()</div><div class=\"line\">subscribe(final Action1&lt;? super T&gt; onNext) </div><div class=\"line\">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</div><div class=\"line\">subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError) </div><div class=\"line\">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</div><div class=\"line\">subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted)</div></pre></td></tr></table></figure></p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p> 讲到现在，对Rxjava的使用也有了清晰的了解，在这里并没有提到Scheduler的使用，我觉得Scheduler  对于Rxjava是十分重要的一部分，我打算在下一篇中做详细的介绍，并对Observable其他重要的API方法进行介绍。</p>\n","excerpt":"<p><img src=\"/imgs/8c91ad2096d7aaea9dc52dc4c86a8d58.jpg\" alt=\"配图\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在 <a href=\"http://www.jianshu.com/p/264a1322669a\">Rxjava学习:初识Rxjava</a> 一文中，我们对Rxjava的几个基本概念做了介绍，今天就来谈谈对Rxjava的使用。<br>","more":"</p>\n<h3 id=\"Rxjava的具体使用\"><a href=\"#Rxjava的具体使用\" class=\"headerlink\" title=\"Rxjava的具体使用\"></a>Rxjava的具体使用</h3><p>下面还是从几个基本概念开始入手：</p>\n<h4 id=\"创建Observer\"><a href=\"#创建Observer\" class=\"headerlink\" title=\"创建Observer\"></a>创建Observer</h4><p>作为Rxjava处理数据的最终出口，首先我们需要对其进行实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onNext(String s) &#123;</div><div class=\"line\">        Log.d(tag, &quot;Item: &quot; + s);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onCompleted() &#123;</div><div class=\"line\">        Log.d(tag, &quot;Completed!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onError(Throwable e) &#123;</div><div class=\"line\">        Log.d(tag, &quot;Error!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>除了 Observer 接口之外，RxJava 还提供了一个实现了 Observer 的抽象类：Subscriber。实际上在Observer接口的使用过程中，也是将其转换成Subscriber 来使用。<br> 下面我们来看一下订阅方法的源码实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final Subscription subscribe(final Observer&lt;? super T&gt; observer) &#123;</div><div class=\"line\">    if (observer instanceof Subscriber) &#123;</div><div class=\"line\">        return subscribe((Subscriber&lt;? super T&gt;)observer);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (observer == null) &#123;</div><div class=\"line\">        throw new NullPointerException(&quot;observer is null&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return subscribe(new ObserverSubscriber&lt;T&gt;(observer));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到 如果是 <strong>Subscriber</strong> 将直接被使用，如果是<strong>observer</strong>将被转换为 <strong>ObserverSubscriber</strong> 来使用。这里提到了<strong> ObserverSubscriber </strong>类 我们再来看一下 其源码，就会很清晰的理解这个过程了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final class ObserverSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; &#123;</div><div class=\"line\">    final Observer&lt;? super T&gt; observer;</div><div class=\"line\">    public ObserverSubscriber(Observer&lt;? super T&gt; observer) &#123;</div><div class=\"line\">        this.observer = observer;</div><div class=\"line\">    &#125;</div><div class=\"line\">        @Override</div><div class=\"line\">    public void onNext(T t) &#123;</div><div class=\"line\">        observer.onNext(t);</div><div class=\"line\">    &#125;</div><div class=\"line\">        @Override</div><div class=\"line\">    public void onError(Throwable e) &#123;</div><div class=\"line\">        observer.onError(e);</div><div class=\"line\">    &#125;</div><div class=\"line\">        @Override</div><div class=\"line\">    public void onCompleted() &#123;</div><div class=\"line\">        observer.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当然Subscriber 对 Observer 接口也进行了一些扩展。 下面提一下 Subscriber 与 Observer 使用上的不同：</p>\n<ul>\n<li><p>onStart(): Subscriber 对外提供了onStart 方法用于实现，onStart 在Subscriber中是一个空方法，用户可以选择性实现。<strong>会在整个订阅过程开始之前被调用，与Subscribe()方法发生在同一线程，可以做一些 比如：数据的初始化 之类的操作，但不适合做对线程有具体要求的工作。例如：初始化UI界面，必须发生在主线程。</strong></p>\n</li>\n<li><p>unsubscribe(): Subscriber 同时实现了另一个接口 Subscription ，Subscription 接口只提供了两个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Subscription &#123;</div><div class=\"line\">        void unsubscribe();</div><div class=\"line\">        boolean isUnsubscribed();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Subscriber 对这两个方法分别做了实现，isUnsubscribed() 用于判断Subscriber 是否已经订阅 ，而 unsubscribe() 方法用于 取消订阅。在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</p>\n<h4 id=\"创建-Observable\"><a href=\"#创建-Observable\" class=\"headerlink\" title=\"创建 Observable\"></a>创建 Observable</h4><p>Observable 提供了大量的方法来进行 数据变换，下面我们借用 <a href=\"http://www.jianshu.com/p/264a1322669a\">Rxjava学习:初识Rxjava</a> 一文中的例子来对其各个API进行理解：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(folders)</div><div class=\"line\">    .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Observable&lt;File&gt; call(File file) &#123;</div><div class=\"line\">            return Observable.from(file.listFiles());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .filter(new Func1&lt;File, Boolean&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Boolean call(File file) &#123;</div><div class=\"line\">            return file.getName().endsWith(&quot;.png&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .map(new Func1&lt;File, Bitmap&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Bitmap call(File file) &#123;</div><div class=\"line\">            return getBitmapFromFile(file);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">    .subscribe(new Action1&lt;Bitmap&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void call(Bitmap bitmap) &#123;</div><div class=\"line\">            imageCollectorView.addImage(bitmap);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>flatMap() : 通过传入的对象，根据需求 ，创建新的Observable 对象，并代替现有的Observable对象完成剩下的所要执行的方法。</p>\n</li>\n<li><p>map() : 将传入的对象转换成另一个对象,是可以被直接发送到了Subscriber 的回调方法中使用的。如同上面示例中那样。</p>\n</li>\n<li><p>filter() : 过滤筛选。 通过事件方法进行筛选，将符合要求的数据传递到下一个事件。例如示例中：符合<strong>file.getName().endsWith(“.png”)</strong> 要求的数据才会传递。</p>\n</li>\n</ul>\n<h4 id=\"调用-subscribe-进行订阅\"><a href=\"#调用-subscribe-进行订阅\" class=\"headerlink\" title=\"调用 subscribe() 进行订阅\"></a>调用 subscribe() 进行订阅</h4><p>创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">observable.subscribe(observer);</div></pre></td></tr></table></figure></p>\n<p>同时subscribe()方法也提供了其他的重载以实现不完整定义的回调。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 自动创建 Subscriber ，并使用 onNext 来定义 onNext()</div><div class=\"line\">subscribe(final Action1&lt;? super T&gt; onNext) </div><div class=\"line\">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</div><div class=\"line\">subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError) </div><div class=\"line\">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</div><div class=\"line\">subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted)</div></pre></td></tr></table></figure></p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p> 讲到现在，对Rxjava的使用也有了清晰的了解，在这里并没有提到Scheduler的使用，我觉得Scheduler  对于Rxjava是十分重要的一部分，我打算在下一篇中做详细的介绍，并对Observable其他重要的API方法进行介绍。</p>"},{"title":"图片加载库Glide的入门使用","date":"2016-11-25T08:15:44.000Z","_content":"### 前言\n在android开发如此盛行的今天，图片加载一直是开发的一个要点，市面上的图片加载库也是层出不穷，选择一个适合当前功能使用的图片加载库十分重要。\n<!-- more-->\n### 使用过的图片加载库\nUniversal Image Loader：最初开始使用的，足够强大，包含各种各样的配置，能满足你各种需求。\nPicasso: Square出品，能和OkHttp搭配使用，唯一不足的是不能加载Gif图片。\nFresco：Facebook出的，十分强大，然而功能过于繁杂，使用起来比较麻烦。\nGlide：专注于平滑图片加载，用于滚动时加载图片时相当流畅。\n\n### Glide的使用\n\n> 加载图片:load()-Glide 做了不同的重载用来支持本地及网络图片的加载\n\n- load(String string)\tstring可以为一个文件路径、uri或者url\n- load(Uri uri)                 Uri类型\n- load(File file)  \t        文件\n- load(Integer resourceId)\t资源Id,R.drawable.xxx或者R.mipmap.xxx\n- load(byte[] model)\tbyte[]类型\n- load(T model)\t自定义类型\n\n```\nGlide.with(context).load(imageUrl).into(imageView);\n```\n\nGlide的with()方法不光支持Context，还支持Activity 和 Fragment，有一点很重要需要记住，就是传入的context类型影响到Glide加载图片的优化程度，Glide可以监视activity的生命周期，在activity销毁的时候自动取消等待中的请求。但是如果你使用Application context，你就失去了这种优化效果。\n\n> 加载网络图片时,placeholder(Drawable drawable) 或者 placeholder(int resourceId)设置等待时显示的图片 ；通过 error(Drawable drawable) 或者 error(int resourceId)设置图片加载失败时显示的图片。\n\n```\nGlide.with(mContext).load(url).placeholder(drawable).error(drawable).into(imgView);\n```\n> Glide 提供了两种缩放方式 ：fitCenter()和 centerCorp()\n\n```\nGlide.with(mContext).load(url).fitCenter().into(imgView);\nGlide.with(mContext).load(url).centerCrop().into(imgView);\n```\n缩放方式不多做介绍，其与scaleType 中的 fitCenter/centerCorp效果是一样的。\n\n> 加载Gif图片\n\n```\nGlide.with(context).load(imageUrl).asGif().placeholder(drawable).error(drawable).into(imageView);\n```\nasGif() 方法判断所要加载的图片是否为 gif图，如果是则正常加载，如果不是则调用error()。也可以无需调用asGif() ,直接加载gif。\n\n> 图片缓存\n\nGlide 提供了多种不同的缓存策略，例如：skipMemoryCache(boolean skip) 判断是否直接跳过内存缓存\n```\nGlide.with(context).load(imageUrl).skipMemoryCache(true).into(imageView);\n```\n同时，对于磁盘缓存也做了多种扩展：\n- DiskCacheStrategy.NONE 不做磁盘缓存\n- DiskCacheStrategy.SOURCE 只缓存图像原图\n- DiskCacheStrategy.RESULT 只缓存加载后的图像，即处理后最终显示时的图像\n- DiskCacheStrategy.ALL 缓存所有版本的图像（默认行为）\n\n调用diskCacheStrategy(DiskCacheStrategy strategy)设置磁盘缓存\n```\n\tGlide.with(context).load(imageUrl).diskCacheStrategy(strategy).into(imageView);\n```\n\n> 图片加载优先级设定\n\nGlide 引入优先级概念，提供了多种优先级设定：\n- Priority.LOW\n- Priority.NORMAL （默认优先级）\n- Priority.HIGH\n- Priority.IMMEDIATE  \n\n调用priority(Priority priority) 指定优先级\n```\nGlide.with(context).load(imageUrl).priority(priority).into(imageView);\n```\n\n> Bitmap 的获取\n\n```\nGlide.with(mContext)\n    .load(url) \n    .placeholder(drawable)\n    .into(new SimpleTarget<Bitmap>(width, height) {\n        @Override \n        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {\n            // setImageBitmap(bitmap)\n        } \n    };\n```\n\n### Glide 扩展使用\n\n> 定义圆形图片加载\n\n```\n//圆形转换\npublic class GlideCircleTransform extends BitmapTransformation {\n    public GlideCircleTransform(Context context) {\n        super(context);\n    }\n\n    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {\n        return circleCrop(pool, toTransform);\n    }\n\n    private static Bitmap circleCrop(BitmapPool pool, Bitmap source) {\n        if (source == null) return null;\n\n        int size = Math.min(source.getWidth(), source.getHeight());\n        int x = (source.getWidth() - size) / 2;\n        int y = (source.getHeight() - size) / 2;\n\n        // TODO this could be acquired from the pool too\n        Bitmap squared = Bitmap.createBitmap(source, x, y, size, size);\n\n        Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888);\n        if (result == null) {\n            result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);\n        }\n\n        Canvas canvas = new Canvas(result);\n        Paint paint = new Paint();\n        paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));\n        paint.setAntiAlias(true);\n        float r = size / 2f;\n        canvas.drawCircle(r, r, r, paint);\n        return result;\n    }\n\n    @Override public String getId() {\n        return getClass().getName();\n    }\n}\n```\n调用transform(Transformation... transformations) 方法完成转换\n```\nGlide.with(this).load(imageUrl).transform(new GlideCircleTransform(context)).into(imageView);\n```\n\n> 圆角图片加载\n\n```\npublic class GlideRoundTransform extends BitmapTransformation {\n\n    private static  float radius = 0f;\n\n    public GlideRoundTransform(Context context) {\n        this(context,15);\n    }\n\n    public GlideRoundTransform(Context context, int dp) {\n        super(context);\n        GlideRoundTransform.radius = Resources.getSystem().getDisplayMetrics().density * dp;\n    }\n\n    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {\n        return roundCrop(pool, toTransform);\n    }\n\n    private static Bitmap roundCrop(BitmapPool pool, Bitmap source) {\n        if (source == null) return null;\n\n        Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);\n        if (result == null) {\n            result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);\n        }\n\n        Canvas canvas = new Canvas(result);\n        Paint paint = new Paint();\n        paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));\n        paint.setAntiAlias(true);\n        RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight());\n        canvas.drawRoundRect(rectF, radius, radius, paint);\n        return result;\n    }\n\n    @Override public String getId() {\n        return getClass().getName() + Math.round(radius);\n    }\n}\n\n```\n使用方式与圆形相同。\n\n> 当列表快速滑动时，暂停请求：pauseRequests()\n\n```\nGlide.with(context). pauseRequests();\n```\n\n> 当列表停止滑动时，重新请求：resumeRequests()\n\n```\nGlide.with(context).resumeRequests();\n```\n\n> 快速取消所有图片请求：clear()\n\n```\nGlide.with(context). clear();\n```\n\n### 使用过程中遇到的问题\n\n> 当Glide用于将图片加载到自定义的Imageview时，需要设置占位图,加载的图片无法显示。\n\n网上有很多解决方案，这里说一个我发现的一个简单方法： **设置一个显示动画**，这样就可以了，原因这里我就不详细深究了。\n```\nGlide.with(context).load(imageUrl).placeholder(drawable)\n\t\t\t.animate(R.anim.abc_fade_in).into(imgView);\n```","source":"_posts/图片加载库Glide的入门使用.md","raw":"---\ntitle: 图片加载库Glide的入门使用\ndate: 2016-11-25 16:15:44\ntags:\ncategories: Glide的使用\n---\n### 前言\n在android开发如此盛行的今天，图片加载一直是开发的一个要点，市面上的图片加载库也是层出不穷，选择一个适合当前功能使用的图片加载库十分重要。\n<!-- more-->\n### 使用过的图片加载库\nUniversal Image Loader：最初开始使用的，足够强大，包含各种各样的配置，能满足你各种需求。\nPicasso: Square出品，能和OkHttp搭配使用，唯一不足的是不能加载Gif图片。\nFresco：Facebook出的，十分强大，然而功能过于繁杂，使用起来比较麻烦。\nGlide：专注于平滑图片加载，用于滚动时加载图片时相当流畅。\n\n### Glide的使用\n\n> 加载图片:load()-Glide 做了不同的重载用来支持本地及网络图片的加载\n\n- load(String string)\tstring可以为一个文件路径、uri或者url\n- load(Uri uri)                 Uri类型\n- load(File file)  \t        文件\n- load(Integer resourceId)\t资源Id,R.drawable.xxx或者R.mipmap.xxx\n- load(byte[] model)\tbyte[]类型\n- load(T model)\t自定义类型\n\n```\nGlide.with(context).load(imageUrl).into(imageView);\n```\n\nGlide的with()方法不光支持Context，还支持Activity 和 Fragment，有一点很重要需要记住，就是传入的context类型影响到Glide加载图片的优化程度，Glide可以监视activity的生命周期，在activity销毁的时候自动取消等待中的请求。但是如果你使用Application context，你就失去了这种优化效果。\n\n> 加载网络图片时,placeholder(Drawable drawable) 或者 placeholder(int resourceId)设置等待时显示的图片 ；通过 error(Drawable drawable) 或者 error(int resourceId)设置图片加载失败时显示的图片。\n\n```\nGlide.with(mContext).load(url).placeholder(drawable).error(drawable).into(imgView);\n```\n> Glide 提供了两种缩放方式 ：fitCenter()和 centerCorp()\n\n```\nGlide.with(mContext).load(url).fitCenter().into(imgView);\nGlide.with(mContext).load(url).centerCrop().into(imgView);\n```\n缩放方式不多做介绍，其与scaleType 中的 fitCenter/centerCorp效果是一样的。\n\n> 加载Gif图片\n\n```\nGlide.with(context).load(imageUrl).asGif().placeholder(drawable).error(drawable).into(imageView);\n```\nasGif() 方法判断所要加载的图片是否为 gif图，如果是则正常加载，如果不是则调用error()。也可以无需调用asGif() ,直接加载gif。\n\n> 图片缓存\n\nGlide 提供了多种不同的缓存策略，例如：skipMemoryCache(boolean skip) 判断是否直接跳过内存缓存\n```\nGlide.with(context).load(imageUrl).skipMemoryCache(true).into(imageView);\n```\n同时，对于磁盘缓存也做了多种扩展：\n- DiskCacheStrategy.NONE 不做磁盘缓存\n- DiskCacheStrategy.SOURCE 只缓存图像原图\n- DiskCacheStrategy.RESULT 只缓存加载后的图像，即处理后最终显示时的图像\n- DiskCacheStrategy.ALL 缓存所有版本的图像（默认行为）\n\n调用diskCacheStrategy(DiskCacheStrategy strategy)设置磁盘缓存\n```\n\tGlide.with(context).load(imageUrl).diskCacheStrategy(strategy).into(imageView);\n```\n\n> 图片加载优先级设定\n\nGlide 引入优先级概念，提供了多种优先级设定：\n- Priority.LOW\n- Priority.NORMAL （默认优先级）\n- Priority.HIGH\n- Priority.IMMEDIATE  \n\n调用priority(Priority priority) 指定优先级\n```\nGlide.with(context).load(imageUrl).priority(priority).into(imageView);\n```\n\n> Bitmap 的获取\n\n```\nGlide.with(mContext)\n    .load(url) \n    .placeholder(drawable)\n    .into(new SimpleTarget<Bitmap>(width, height) {\n        @Override \n        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) {\n            // setImageBitmap(bitmap)\n        } \n    };\n```\n\n### Glide 扩展使用\n\n> 定义圆形图片加载\n\n```\n//圆形转换\npublic class GlideCircleTransform extends BitmapTransformation {\n    public GlideCircleTransform(Context context) {\n        super(context);\n    }\n\n    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {\n        return circleCrop(pool, toTransform);\n    }\n\n    private static Bitmap circleCrop(BitmapPool pool, Bitmap source) {\n        if (source == null) return null;\n\n        int size = Math.min(source.getWidth(), source.getHeight());\n        int x = (source.getWidth() - size) / 2;\n        int y = (source.getHeight() - size) / 2;\n\n        // TODO this could be acquired from the pool too\n        Bitmap squared = Bitmap.createBitmap(source, x, y, size, size);\n\n        Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888);\n        if (result == null) {\n            result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);\n        }\n\n        Canvas canvas = new Canvas(result);\n        Paint paint = new Paint();\n        paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));\n        paint.setAntiAlias(true);\n        float r = size / 2f;\n        canvas.drawCircle(r, r, r, paint);\n        return result;\n    }\n\n    @Override public String getId() {\n        return getClass().getName();\n    }\n}\n```\n调用transform(Transformation... transformations) 方法完成转换\n```\nGlide.with(this).load(imageUrl).transform(new GlideCircleTransform(context)).into(imageView);\n```\n\n> 圆角图片加载\n\n```\npublic class GlideRoundTransform extends BitmapTransformation {\n\n    private static  float radius = 0f;\n\n    public GlideRoundTransform(Context context) {\n        this(context,15);\n    }\n\n    public GlideRoundTransform(Context context, int dp) {\n        super(context);\n        GlideRoundTransform.radius = Resources.getSystem().getDisplayMetrics().density * dp;\n    }\n\n    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {\n        return roundCrop(pool, toTransform);\n    }\n\n    private static Bitmap roundCrop(BitmapPool pool, Bitmap source) {\n        if (source == null) return null;\n\n        Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);\n        if (result == null) {\n            result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);\n        }\n\n        Canvas canvas = new Canvas(result);\n        Paint paint = new Paint();\n        paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));\n        paint.setAntiAlias(true);\n        RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight());\n        canvas.drawRoundRect(rectF, radius, radius, paint);\n        return result;\n    }\n\n    @Override public String getId() {\n        return getClass().getName() + Math.round(radius);\n    }\n}\n\n```\n使用方式与圆形相同。\n\n> 当列表快速滑动时，暂停请求：pauseRequests()\n\n```\nGlide.with(context). pauseRequests();\n```\n\n> 当列表停止滑动时，重新请求：resumeRequests()\n\n```\nGlide.with(context).resumeRequests();\n```\n\n> 快速取消所有图片请求：clear()\n\n```\nGlide.with(context). clear();\n```\n\n### 使用过程中遇到的问题\n\n> 当Glide用于将图片加载到自定义的Imageview时，需要设置占位图,加载的图片无法显示。\n\n网上有很多解决方案，这里说一个我发现的一个简单方法： **设置一个显示动画**，这样就可以了，原因这里我就不详细深究了。\n```\nGlide.with(context).load(imageUrl).placeholder(drawable)\n\t\t\t.animate(R.anim.abc_fade_in).into(imgView);\n```","slug":"图片加载库Glide的入门使用","published":1,"updated":"2016-11-25T08:18:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovdv2000nbqc6qky68meu","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在android开发如此盛行的今天，图片加载一直是开发的一个要点，市面上的图片加载库也是层出不穷，选择一个适合当前功能使用的图片加载库十分重要。<br><a id=\"more\"></a></p>\n<h3 id=\"使用过的图片加载库\"><a href=\"#使用过的图片加载库\" class=\"headerlink\" title=\"使用过的图片加载库\"></a>使用过的图片加载库</h3><p>Universal Image Loader：最初开始使用的，足够强大，包含各种各样的配置，能满足你各种需求。<br>Picasso: Square出品，能和OkHttp搭配使用，唯一不足的是不能加载Gif图片。<br>Fresco：Facebook出的，十分强大，然而功能过于繁杂，使用起来比较麻烦。<br>Glide：专注于平滑图片加载，用于滚动时加载图片时相当流畅。</p>\n<h3 id=\"Glide的使用\"><a href=\"#Glide的使用\" class=\"headerlink\" title=\"Glide的使用\"></a>Glide的使用</h3><blockquote>\n<p>加载图片:load()-Glide 做了不同的重载用来支持本地及网络图片的加载</p>\n</blockquote>\n<ul>\n<li>load(String string)    string可以为一个文件路径、uri或者url</li>\n<li>load(Uri uri)                 Uri类型</li>\n<li>load(File file)              文件</li>\n<li>load(Integer resourceId)    资源Id,R.drawable.xxx或者R.mipmap.xxx</li>\n<li>load(byte[] model)    byte[]类型</li>\n<li>load(T model)    自定义类型</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).into(imageView);</div></pre></td></tr></table></figure>\n<p>Glide的with()方法不光支持Context，还支持Activity 和 Fragment，有一点很重要需要记住，就是传入的context类型影响到Glide加载图片的优化程度，Glide可以监视activity的生命周期，在activity销毁的时候自动取消等待中的请求。但是如果你使用Application context，你就失去了这种优化效果。</p>\n<blockquote>\n<p>加载网络图片时,placeholder(Drawable drawable) 或者 placeholder(int resourceId)设置等待时显示的图片 ；通过 error(Drawable drawable) 或者 error(int resourceId)设置图片加载失败时显示的图片。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(mContext).load(url).placeholder(drawable).error(drawable).into(imgView);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Glide 提供了两种缩放方式 ：fitCenter()和 centerCorp()</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(mContext).load(url).fitCenter().into(imgView);</div><div class=\"line\">Glide.with(mContext).load(url).centerCrop().into(imgView);</div></pre></td></tr></table></figure>\n<p>缩放方式不多做介绍，其与scaleType 中的 fitCenter/centerCorp效果是一样的。</p>\n<blockquote>\n<p>加载Gif图片</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).asGif().placeholder(drawable).error(drawable).into(imageView);</div></pre></td></tr></table></figure>\n<p>asGif() 方法判断所要加载的图片是否为 gif图，如果是则正常加载，如果不是则调用error()。也可以无需调用asGif() ,直接加载gif。</p>\n<blockquote>\n<p>图片缓存</p>\n</blockquote>\n<p>Glide 提供了多种不同的缓存策略，例如：skipMemoryCache(boolean skip) 判断是否直接跳过内存缓存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).skipMemoryCache(true).into(imageView);</div></pre></td></tr></table></figure></p>\n<p>同时，对于磁盘缓存也做了多种扩展：</p>\n<ul>\n<li>DiskCacheStrategy.NONE 不做磁盘缓存</li>\n<li>DiskCacheStrategy.SOURCE 只缓存图像原图</li>\n<li>DiskCacheStrategy.RESULT 只缓存加载后的图像，即处理后最终显示时的图像</li>\n<li>DiskCacheStrategy.ALL 缓存所有版本的图像（默认行为）</li>\n</ul>\n<p>调用diskCacheStrategy(DiskCacheStrategy strategy)设置磁盘缓存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).diskCacheStrategy(strategy).into(imageView);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>图片加载优先级设定</p>\n</blockquote>\n<p>Glide 引入优先级概念，提供了多种优先级设定：</p>\n<ul>\n<li>Priority.LOW</li>\n<li>Priority.NORMAL （默认优先级）</li>\n<li>Priority.HIGH</li>\n<li>Priority.IMMEDIATE  </li>\n</ul>\n<p>调用priority(Priority priority) 指定优先级<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).priority(priority).into(imageView);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Bitmap 的获取</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(mContext)</div><div class=\"line\">    .load(url) </div><div class=\"line\">    .placeholder(drawable)</div><div class=\"line\">    .into(new SimpleTarget&lt;Bitmap&gt;(width, height) &#123;</div><div class=\"line\">        @Override </div><div class=\"line\">        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) &#123;</div><div class=\"line\">            // setImageBitmap(bitmap)</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"Glide-扩展使用\"><a href=\"#Glide-扩展使用\" class=\"headerlink\" title=\"Glide 扩展使用\"></a>Glide 扩展使用</h3><blockquote>\n<p>定义圆形图片加载</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">//圆形转换</div><div class=\"line\">public class GlideCircleTransform extends BitmapTransformation &#123;</div><div class=\"line\">    public GlideCircleTransform(Context context) &#123;</div><div class=\"line\">        super(context);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;</div><div class=\"line\">        return circleCrop(pool, toTransform);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private static Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123;</div><div class=\"line\">        if (source == null) return null;</div><div class=\"line\"></div><div class=\"line\">        int size = Math.min(source.getWidth(), source.getHeight());</div><div class=\"line\">        int x = (source.getWidth() - size) / 2;</div><div class=\"line\">        int y = (source.getHeight() - size) / 2;</div><div class=\"line\"></div><div class=\"line\">        // TODO this could be acquired from the pool too</div><div class=\"line\">        Bitmap squared = Bitmap.createBitmap(source, x, y, size, size);</div><div class=\"line\"></div><div class=\"line\">        Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888);</div><div class=\"line\">        if (result == null) &#123;</div><div class=\"line\">            result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Canvas canvas = new Canvas(result);</div><div class=\"line\">        Paint paint = new Paint();</div><div class=\"line\">        paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));</div><div class=\"line\">        paint.setAntiAlias(true);</div><div class=\"line\">        float r = size / 2f;</div><div class=\"line\">        canvas.drawCircle(r, r, r, paint);</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override public String getId() &#123;</div><div class=\"line\">        return getClass().getName();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用transform(Transformation… transformations) 方法完成转换<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(this).load(imageUrl).transform(new GlideCircleTransform(context)).into(imageView);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>圆角图片加载</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class GlideRoundTransform extends BitmapTransformation &#123;</div><div class=\"line\"></div><div class=\"line\">    private static  float radius = 0f;</div><div class=\"line\"></div><div class=\"line\">    public GlideRoundTransform(Context context) &#123;</div><div class=\"line\">        this(context,15);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public GlideRoundTransform(Context context, int dp) &#123;</div><div class=\"line\">        super(context);</div><div class=\"line\">        GlideRoundTransform.radius = Resources.getSystem().getDisplayMetrics().density * dp;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;</div><div class=\"line\">        return roundCrop(pool, toTransform);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123;</div><div class=\"line\">        if (source == null) return null;</div><div class=\"line\"></div><div class=\"line\">        Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</div><div class=\"line\">        if (result == null) &#123;</div><div class=\"line\">            result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Canvas canvas = new Canvas(result);</div><div class=\"line\">        Paint paint = new Paint();</div><div class=\"line\">        paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));</div><div class=\"line\">        paint.setAntiAlias(true);</div><div class=\"line\">        RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight());</div><div class=\"line\">        canvas.drawRoundRect(rectF, radius, radius, paint);</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override public String getId() &#123;</div><div class=\"line\">        return getClass().getName() + Math.round(radius);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用方式与圆形相同。</p>\n<blockquote>\n<p>当列表快速滑动时，暂停请求：pauseRequests()</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context). pauseRequests();</div></pre></td></tr></table></figure>\n<blockquote>\n<p>当列表停止滑动时，重新请求：resumeRequests()</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).resumeRequests();</div></pre></td></tr></table></figure>\n<blockquote>\n<p>快速取消所有图片请求：clear()</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context). clear();</div></pre></td></tr></table></figure>\n<h3 id=\"使用过程中遇到的问题\"><a href=\"#使用过程中遇到的问题\" class=\"headerlink\" title=\"使用过程中遇到的问题\"></a>使用过程中遇到的问题</h3><blockquote>\n<p>当Glide用于将图片加载到自定义的Imageview时，需要设置占位图,加载的图片无法显示。</p>\n</blockquote>\n<p>网上有很多解决方案，这里说一个我发现的一个简单方法： <strong>设置一个显示动画</strong>，这样就可以了，原因这里我就不详细深究了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).placeholder(drawable)</div><div class=\"line\">\t\t\t.animate(R.anim.abc_fade_in).into(imgView);</div></pre></td></tr></table></figure></p>\n","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在android开发如此盛行的今天，图片加载一直是开发的一个要点，市面上的图片加载库也是层出不穷，选择一个适合当前功能使用的图片加载库十分重要。<br>","more":"</p>\n<h3 id=\"使用过的图片加载库\"><a href=\"#使用过的图片加载库\" class=\"headerlink\" title=\"使用过的图片加载库\"></a>使用过的图片加载库</h3><p>Universal Image Loader：最初开始使用的，足够强大，包含各种各样的配置，能满足你各种需求。<br>Picasso: Square出品，能和OkHttp搭配使用，唯一不足的是不能加载Gif图片。<br>Fresco：Facebook出的，十分强大，然而功能过于繁杂，使用起来比较麻烦。<br>Glide：专注于平滑图片加载，用于滚动时加载图片时相当流畅。</p>\n<h3 id=\"Glide的使用\"><a href=\"#Glide的使用\" class=\"headerlink\" title=\"Glide的使用\"></a>Glide的使用</h3><blockquote>\n<p>加载图片:load()-Glide 做了不同的重载用来支持本地及网络图片的加载</p>\n</blockquote>\n<ul>\n<li>load(String string)    string可以为一个文件路径、uri或者url</li>\n<li>load(Uri uri)                 Uri类型</li>\n<li>load(File file)              文件</li>\n<li>load(Integer resourceId)    资源Id,R.drawable.xxx或者R.mipmap.xxx</li>\n<li>load(byte[] model)    byte[]类型</li>\n<li>load(T model)    自定义类型</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).into(imageView);</div></pre></td></tr></table></figure>\n<p>Glide的with()方法不光支持Context，还支持Activity 和 Fragment，有一点很重要需要记住，就是传入的context类型影响到Glide加载图片的优化程度，Glide可以监视activity的生命周期，在activity销毁的时候自动取消等待中的请求。但是如果你使用Application context，你就失去了这种优化效果。</p>\n<blockquote>\n<p>加载网络图片时,placeholder(Drawable drawable) 或者 placeholder(int resourceId)设置等待时显示的图片 ；通过 error(Drawable drawable) 或者 error(int resourceId)设置图片加载失败时显示的图片。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(mContext).load(url).placeholder(drawable).error(drawable).into(imgView);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Glide 提供了两种缩放方式 ：fitCenter()和 centerCorp()</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(mContext).load(url).fitCenter().into(imgView);</div><div class=\"line\">Glide.with(mContext).load(url).centerCrop().into(imgView);</div></pre></td></tr></table></figure>\n<p>缩放方式不多做介绍，其与scaleType 中的 fitCenter/centerCorp效果是一样的。</p>\n<blockquote>\n<p>加载Gif图片</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).asGif().placeholder(drawable).error(drawable).into(imageView);</div></pre></td></tr></table></figure>\n<p>asGif() 方法判断所要加载的图片是否为 gif图，如果是则正常加载，如果不是则调用error()。也可以无需调用asGif() ,直接加载gif。</p>\n<blockquote>\n<p>图片缓存</p>\n</blockquote>\n<p>Glide 提供了多种不同的缓存策略，例如：skipMemoryCache(boolean skip) 判断是否直接跳过内存缓存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).skipMemoryCache(true).into(imageView);</div></pre></td></tr></table></figure></p>\n<p>同时，对于磁盘缓存也做了多种扩展：</p>\n<ul>\n<li>DiskCacheStrategy.NONE 不做磁盘缓存</li>\n<li>DiskCacheStrategy.SOURCE 只缓存图像原图</li>\n<li>DiskCacheStrategy.RESULT 只缓存加载后的图像，即处理后最终显示时的图像</li>\n<li>DiskCacheStrategy.ALL 缓存所有版本的图像（默认行为）</li>\n</ul>\n<p>调用diskCacheStrategy(DiskCacheStrategy strategy)设置磁盘缓存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).diskCacheStrategy(strategy).into(imageView);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>图片加载优先级设定</p>\n</blockquote>\n<p>Glide 引入优先级概念，提供了多种优先级设定：</p>\n<ul>\n<li>Priority.LOW</li>\n<li>Priority.NORMAL （默认优先级）</li>\n<li>Priority.HIGH</li>\n<li>Priority.IMMEDIATE  </li>\n</ul>\n<p>调用priority(Priority priority) 指定优先级<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).priority(priority).into(imageView);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Bitmap 的获取</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(mContext)</div><div class=\"line\">    .load(url) </div><div class=\"line\">    .placeholder(drawable)</div><div class=\"line\">    .into(new SimpleTarget&lt;Bitmap&gt;(width, height) &#123;</div><div class=\"line\">        @Override </div><div class=\"line\">        public void onResourceReady(Bitmap bitmap, GlideAnimation anim) &#123;</div><div class=\"line\">            // setImageBitmap(bitmap)</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"Glide-扩展使用\"><a href=\"#Glide-扩展使用\" class=\"headerlink\" title=\"Glide 扩展使用\"></a>Glide 扩展使用</h3><blockquote>\n<p>定义圆形图片加载</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">//圆形转换</div><div class=\"line\">public class GlideCircleTransform extends BitmapTransformation &#123;</div><div class=\"line\">    public GlideCircleTransform(Context context) &#123;</div><div class=\"line\">        super(context);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;</div><div class=\"line\">        return circleCrop(pool, toTransform);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private static Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123;</div><div class=\"line\">        if (source == null) return null;</div><div class=\"line\"></div><div class=\"line\">        int size = Math.min(source.getWidth(), source.getHeight());</div><div class=\"line\">        int x = (source.getWidth() - size) / 2;</div><div class=\"line\">        int y = (source.getHeight() - size) / 2;</div><div class=\"line\"></div><div class=\"line\">        // TODO this could be acquired from the pool too</div><div class=\"line\">        Bitmap squared = Bitmap.createBitmap(source, x, y, size, size);</div><div class=\"line\"></div><div class=\"line\">        Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888);</div><div class=\"line\">        if (result == null) &#123;</div><div class=\"line\">            result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Canvas canvas = new Canvas(result);</div><div class=\"line\">        Paint paint = new Paint();</div><div class=\"line\">        paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));</div><div class=\"line\">        paint.setAntiAlias(true);</div><div class=\"line\">        float r = size / 2f;</div><div class=\"line\">        canvas.drawCircle(r, r, r, paint);</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override public String getId() &#123;</div><div class=\"line\">        return getClass().getName();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用transform(Transformation… transformations) 方法完成转换<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(this).load(imageUrl).transform(new GlideCircleTransform(context)).into(imageView);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>圆角图片加载</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class GlideRoundTransform extends BitmapTransformation &#123;</div><div class=\"line\"></div><div class=\"line\">    private static  float radius = 0f;</div><div class=\"line\"></div><div class=\"line\">    public GlideRoundTransform(Context context) &#123;</div><div class=\"line\">        this(context,15);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public GlideRoundTransform(Context context, int dp) &#123;</div><div class=\"line\">        super(context);</div><div class=\"line\">        GlideRoundTransform.radius = Resources.getSystem().getDisplayMetrics().density * dp;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;</div><div class=\"line\">        return roundCrop(pool, toTransform);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123;</div><div class=\"line\">        if (source == null) return null;</div><div class=\"line\"></div><div class=\"line\">        Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</div><div class=\"line\">        if (result == null) &#123;</div><div class=\"line\">            result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Canvas canvas = new Canvas(result);</div><div class=\"line\">        Paint paint = new Paint();</div><div class=\"line\">        paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));</div><div class=\"line\">        paint.setAntiAlias(true);</div><div class=\"line\">        RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight());</div><div class=\"line\">        canvas.drawRoundRect(rectF, radius, radius, paint);</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override public String getId() &#123;</div><div class=\"line\">        return getClass().getName() + Math.round(radius);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用方式与圆形相同。</p>\n<blockquote>\n<p>当列表快速滑动时，暂停请求：pauseRequests()</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context). pauseRequests();</div></pre></td></tr></table></figure>\n<blockquote>\n<p>当列表停止滑动时，重新请求：resumeRequests()</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).resumeRequests();</div></pre></td></tr></table></figure>\n<blockquote>\n<p>快速取消所有图片请求：clear()</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context). clear();</div></pre></td></tr></table></figure>\n<h3 id=\"使用过程中遇到的问题\"><a href=\"#使用过程中遇到的问题\" class=\"headerlink\" title=\"使用过程中遇到的问题\"></a>使用过程中遇到的问题</h3><blockquote>\n<p>当Glide用于将图片加载到自定义的Imageview时，需要设置占位图,加载的图片无法显示。</p>\n</blockquote>\n<p>网上有很多解决方案，这里说一个我发现的一个简单方法： <strong>设置一个显示动画</strong>，这样就可以了，原因这里我就不详细深究了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Glide.with(context).load(imageUrl).placeholder(drawable)</div><div class=\"line\">\t\t\t.animate(R.anim.abc_fade_in).into(imgView);</div></pre></td></tr></table></figure></p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags: [hello,world]\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2016-08-18T01:13:42.000Z","updated":"2016-08-24T08:54:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw5ovdv5000qbqc6bogrg4re","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ciw5ovdur0006bqc6i7kwrwoz","category_id":"ciw5ovduo0004bqc622qo2t6l","_id":"ciw5ovduv000abqc66os945ob"},{"post_id":"ciw5ovdug0000bqc6yborqxow","category_id":"ciw5ovduo0004bqc622qo2t6l","_id":"ciw5ovdux000ebqc6iage9ota"},{"post_id":"ciw5ovdus0007bqc6w6e6sgd4","category_id":"ciw5ovduo0004bqc622qo2t6l","_id":"ciw5ovduy000gbqc6rjerbum6"},{"post_id":"ciw5ovdul0002bqc6us2la7w5","category_id":"ciw5ovdut0008bqc6x69uyhvi","_id":"ciw5ovdv0000kbqc618fyx85h"},{"post_id":"ciw5ovdur0005bqc6g3hfn6u4","category_id":"ciw5ovduo0004bqc622qo2t6l","_id":"ciw5ovdv3000obqc647g9qrtu"},{"post_id":"ciw5ovdv1000lbqc6i7pl7ygq","category_id":"ciw5ovdv0000ibqc634kpuwtn","_id":"ciw5ovdv6000sbqc6hxwtlq43"},{"post_id":"ciw5ovduu0009bqc66w58onsy","category_id":"ciw5ovdv0000ibqc634kpuwtn","_id":"ciw5ovdv6000tbqc6ui9zc8qp"},{"post_id":"ciw5ovduv000bbqc697m4te1r","category_id":"ciw5ovdv4000pbqc6k2kisqzx","_id":"ciw5ovdv8000xbqc6c0axmaan"},{"post_id":"ciw5ovdux000fbqc681tfrbyv","category_id":"ciw5ovdv0000ibqc634kpuwtn","_id":"ciw5ovdv90011bqc6637jxedz"},{"post_id":"ciw5ovdv2000nbqc6qky68meu","category_id":"ciw5ovdv8000ybqc66ylr2icp","_id":"ciw5ovdv90014bqc6h7x3srrg"}],"PostTag":[{"post_id":"ciw5ovduu0009bqc66w58onsy","tag_id":"ciw5ovduw000dbqc6gh3rnxx0","_id":"ciw5ovdv2000mbqc6rln74588"},{"post_id":"ciw5ovduv000bbqc697m4te1r","tag_id":"ciw5ovdv0000jbqc6xv2b8o3p","_id":"ciw5ovdv8000wbqc6ohy8x5qk"},{"post_id":"ciw5ovduv000bbqc697m4te1r","tag_id":"ciw5ovdv6000rbqc6neascjs1","_id":"ciw5ovdv8000zbqc6jrb64mwy"},{"post_id":"ciw5ovdux000fbqc681tfrbyv","tag_id":"ciw5ovduw000dbqc6gh3rnxx0","_id":"ciw5ovdv90013bqc6egm9fk3x"},{"post_id":"ciw5ovdux000fbqc681tfrbyv","tag_id":"ciw5ovdv80010bqc6dts87uil","_id":"ciw5ovdva0015bqc6z01wcubg"},{"post_id":"ciw5ovduz000hbqc656jgyu0o","tag_id":"ciw5ovdv90012bqc60lowwzym","_id":"ciw5ovdva0017bqc6szc6zhav"},{"post_id":"ciw5ovdv5000qbqc6bogrg4re","tag_id":"ciw5ovdva0016bqc6dn8tuu31","_id":"ciw5ovdvb0019bqc6ljy1y7m5"},{"post_id":"ciw5ovdv5000qbqc6bogrg4re","tag_id":"ciw5ovdva0018bqc6kkvwn41w","_id":"ciw5ovdvb001abqc6oa0s8dfk"}],"Tag":[{"name":"Rxjava","_id":"ciw5ovduw000dbqc6gh3rnxx0"},{"name":"EventBus2.0","_id":"ciw5ovdv0000jbqc6xv2b8o3p"},{"name":"EventBus3.0","_id":"ciw5ovdv6000rbqc6neascjs1"},{"name":"RxAndroid","_id":"ciw5ovdv80010bqc6dts87uil"},{"name":"Notification","_id":"ciw5ovdv90012bqc60lowwzym"},{"name":"hello","_id":"ciw5ovdva0016bqc6dn8tuu31"},{"name":"world","_id":"ciw5ovdva0018bqc6kkvwn41w"}]}}